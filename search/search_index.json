{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Biodata \u00b6 Nama : Rizaldi Febri Agil Prasetya \u00b6 NIM : 180411100085 \u00b6 Program Studi : Teknik Informatika \u00b6 Fakultas : Teknik \u00b6 Perguruan Tinggi : Universitas Trunojoyo Madura \u00b6 Dosen Pengampu : @mulaab \u00b6 Email : Prasetyaaldi098@gmail.com \u00b6","title":"Rizaldi Febri Agil Prasetya"},{"location":"#welcome","text":"","title":"Welcome"},{"location":"#biodata","text":"","title":"Biodata"},{"location":"#nama-rizaldi-febri-agil-prasetya","text":"","title":"Nama : Rizaldi Febri Agil Prasetya"},{"location":"#nim-180411100085","text":"","title":"NIM : 180411100085"},{"location":"#program-studi-teknik-informatika","text":"","title":"Program Studi : Teknik Informatika"},{"location":"#fakultas-teknik","text":"","title":"Fakultas : Teknik"},{"location":"#perguruan-tinggi-universitas-trunojoyo-madura","text":"","title":"Perguruan Tinggi : Universitas Trunojoyo Madura"},{"location":"#dosen-pengampu-mulaab","text":"","title":"Dosen Pengampu : @mulaab"},{"location":"#email-prasetyaaldi098gmailcom","text":"","title":"Email : Prasetyaaldi098@gmail.com"},{"location":"MeasuringError/","text":"Measuring Error \u00b6 \u200b Kesalahan dalam memecahkan suatu teknik atau ilmu masalah bisa timbul karena beberapa faktor. Pertama, kesalahan mungkin dalam teknik pemodelan. Sebuah model matematika mungkin didasarkan pada menggunakan asumsi yang tidak dapat diterima. Sebagai contoh, seseorang dapat berasumsi bahwa gaya memindahkan gigi pada mobil sebanding dengan kecepatan mobil, tapi sebenarnya itu adalah sebanding dengan kuadrat dari kecepatan mobil. Ini sendiri dapat membuat kesalahan besar dalam menentukan performa mobil, tidak peduli seberapa akurat metode numerik Anda dapat menggunakan yang. Kedua, kesalahan mungkin timbul dari kesalahan dalam program sendiri atau dalam pengukuran kuantitas fisik. Tapi, dalam aplikasi metode numerik sendiri, dua kesalahan kita harus fokus pada adalah : 1. Round of Error \u00b6 \u200b Round off error merupakan sebutan untuk kesalahan pembulatan. Dalam perhitungan angka-angka yang terdiri dari angka atau digit non bulat (pecahan) sulit untuk kita pastikan bahwa nilai itu eksak atau benar adanya. dalam perhitungan menggunakan approxsimasi, pastilah perhitungan tersebut memiliki suatu round off error (kesalahan pembulatan). saat kita memutuskan untuk menggunakan nilai approsimasi, sudah pasti kita memiliki nikai ROE ini. Pada nilai nilai yang sudah di tetapkan seperti \u03c0, e, atau \u221a 7 , meskipun memiliki nilai ketetapan, tapi sesungguhnya nilai-nilai tersebut memiliki round off error yang pasti. 2. Truncation Error \u00b6 \u200b Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi. True Error \u00b6 \u200b Didefinisikan sebagai beda antara nilai eksak dalam penghitungan dan pendekatan menggunakan metode numerik. Relative True Error \u00b6 \u200b Didefinisikan sebagai rasio antara nilai kesalahan eksak dan nilai eksak. ApporixmateError \u00b6 \u200b Kesalahan perkiraan didefinisikan sebagai beda antara nilai perkiraan sekarang (ke-n) beda antara nilai perkiraan sekarang (ke-n) dengan nilai perkiraan sebelumnya (ke-(n-1)). Relative ApproximateError \u00b6 Didefinisikan sebagai rasio antara kesalahan perkiraan dan nilai perkiraan ke-n. Listing Program untuk MACLAURIN \u00b6 import math x = int ( input ( \"masukkan Nilai X : \" )) Percobaan = 1 a = 0 b = 1 while Percobaan > 0.0001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += ( 3 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += ( 3 ** j ) * x ** j / math . factorial ( j ) print ( \"suku ke\" , a , \"=\" , f_x ) print ( \"suku ke\" , b , \"=\" , f_y ) Percobaan = f_y - f_x a += 1 b += 1 print ( \"selisih = \" , coba ) Hasil Output \u00b6 C : \\ Kuliah \\ KomputasiNumerik > python cobakTugas1 . py masukkan Nilai X : 3 suku ke 0 = 0 suku ke 1 = 1.0 selisih = 1.0 suku ke 1 = 1.0 suku ke 2 = 10.0 selisih = 9.0 suku ke 2 = 10.0 suku ke 3 = 50.5 selisih = 40.5 suku ke 3 = 50.5 suku ke 4 = 172.0 selisih = 121.5 suku ke 4 = 172.0 suku ke 5 = 445.375 selisih = 273.375 suku ke 5 = 445.375 suku ke 6 = 937.45 selisih = 492.07500000000005 suku ke 6 = 937.45 suku ke 7 = 1675.5625 selisih = 738.1125 suku ke 7 = 1675.5625 suku ke 8 = 2624.5642857142857 selisih = 949.0017857142857 suku ke 8 = 2624.5642857142857 suku ke 9 = 3692.1912946428574 selisih = 1067.6270089285717 suku ke 9 = 3692.1912946428574 suku ke 10 = 4759.818303571429 selisih = 1067.6270089285717 suku ke 10 = 4759.818303571429 suku ke 11 = 5720.682611607143 selisih = 960.8643080357142 suku ke 11 = 5720.682611607143 suku ke 12 = 6506.844318181818 selisih = 786.161706574675 suku ke 12 = 6506.844318181818 suku ke 13 = 7096.465598112825 selisih = 589.6212799310069 suku ke 13 = 7096.465598112825 suku ke 14 = 7504.6649457573685 selisih = 408.1993476445432 suku ke 14 = 7504.6649457573685 suku ke 15 = 7767.078812100289 selisih = 262.4138663429203 suku ke 15 = 7767.078812100289 suku ke 16 = 7924.527131906041 selisih = 157.44831980575236 suku ke 16 = 7924.527131906041 suku ke 17 = 8013.091811796777 selisih = 88.56467989073553 suku ke 17 = 8013.091811796777 suku ke 18 = 8059.978995268342 selisih = 46.88718347156555 suku ke 18 = 8059.978995268342 suku ke 19 = 8083.4225870041255 selisih = 23.44359173578323 suku ke 19 = 8083.4225870041255 suku ke 20 = 8094.527446247391 selisih = 11.10485924326531 suku ke 20 = 8094.527446247391 suku ke 21 = 8099.5246329068605 selisih = 4.997186659469662 suku ke 21 = 8099.5246329068605 suku ke 22 = 8101.6662843323475 selisih = 2.141651425486998 suku ke 22 = 8101.6662843323475 suku ke 23 = 8102.542414460956 selisih = 0.8761301286085654 suku ke 23 = 8102.542414460956 suku ke 24 = 8102.885247989542 selisih = 0.34283352858619764 suku ke 24 = 8102.885247989542 suku ke 25 = 8103.013810562762 selisih = 0.12856257321982412 suku ke 25 = 8103.013810562762 suku ke 26 = 8103.060093089121 selisih = 0.04628252635939134 suku ke 26 = 8103.060093089121 suku ke 27 = 8103.076113963631 selisih = 0.016020874509194982 suku ke 27 = 8103.076113963631 suku ke 28 = 8103.081454255133 selisih = 0.005340291502761829 suku ke 28 = 8103.081454255133 suku ke 29 = 8103.083170777402 selisih = 0.0017165222689072834 suku ke 29 = 8103.083170777402 suku ke 30 = 8103.08370349121 selisih = 0.0005327138078428106","title":"Measuring Error"},{"location":"MeasuringError/#measuring-error","text":"\u200b Kesalahan dalam memecahkan suatu teknik atau ilmu masalah bisa timbul karena beberapa faktor. Pertama, kesalahan mungkin dalam teknik pemodelan. Sebuah model matematika mungkin didasarkan pada menggunakan asumsi yang tidak dapat diterima. Sebagai contoh, seseorang dapat berasumsi bahwa gaya memindahkan gigi pada mobil sebanding dengan kecepatan mobil, tapi sebenarnya itu adalah sebanding dengan kuadrat dari kecepatan mobil. Ini sendiri dapat membuat kesalahan besar dalam menentukan performa mobil, tidak peduli seberapa akurat metode numerik Anda dapat menggunakan yang. Kedua, kesalahan mungkin timbul dari kesalahan dalam program sendiri atau dalam pengukuran kuantitas fisik. Tapi, dalam aplikasi metode numerik sendiri, dua kesalahan kita harus fokus pada adalah :","title":"Measuring Error"},{"location":"MeasuringError/#1-round-of-error","text":"\u200b Round off error merupakan sebutan untuk kesalahan pembulatan. Dalam perhitungan angka-angka yang terdiri dari angka atau digit non bulat (pecahan) sulit untuk kita pastikan bahwa nilai itu eksak atau benar adanya. dalam perhitungan menggunakan approxsimasi, pastilah perhitungan tersebut memiliki suatu round off error (kesalahan pembulatan). saat kita memutuskan untuk menggunakan nilai approsimasi, sudah pasti kita memiliki nikai ROE ini. Pada nilai nilai yang sudah di tetapkan seperti \u03c0, e, atau \u221a 7 , meskipun memiliki nilai ketetapan, tapi sesungguhnya nilai-nilai tersebut memiliki round off error yang pasti.","title":"1. Round of Error"},{"location":"MeasuringError/#2-truncation-error","text":"\u200b Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.","title":"2. Truncation Error"},{"location":"MeasuringError/#true-error","text":"\u200b Didefinisikan sebagai beda antara nilai eksak dalam penghitungan dan pendekatan menggunakan metode numerik.","title":"True Error"},{"location":"MeasuringError/#relative-true-error","text":"\u200b Didefinisikan sebagai rasio antara nilai kesalahan eksak dan nilai eksak.","title":"Relative True Error"},{"location":"MeasuringError/#apporixmateerror","text":"\u200b Kesalahan perkiraan didefinisikan sebagai beda antara nilai perkiraan sekarang (ke-n) beda antara nilai perkiraan sekarang (ke-n) dengan nilai perkiraan sebelumnya (ke-(n-1)).","title":"ApporixmateError"},{"location":"MeasuringError/#relative-approximateerror","text":"Didefinisikan sebagai rasio antara kesalahan perkiraan dan nilai perkiraan ke-n.","title":"Relative ApproximateError"},{"location":"MeasuringError/#listing-program-untuk-maclaurin","text":"import math x = int ( input ( \"masukkan Nilai X : \" )) Percobaan = 1 a = 0 b = 1 while Percobaan > 0.0001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += ( 3 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += ( 3 ** j ) * x ** j / math . factorial ( j ) print ( \"suku ke\" , a , \"=\" , f_x ) print ( \"suku ke\" , b , \"=\" , f_y ) Percobaan = f_y - f_x a += 1 b += 1 print ( \"selisih = \" , coba )","title":"Listing Program untuk MACLAURIN"},{"location":"MeasuringError/#hasil-output","text":"C : \\ Kuliah \\ KomputasiNumerik > python cobakTugas1 . py masukkan Nilai X : 3 suku ke 0 = 0 suku ke 1 = 1.0 selisih = 1.0 suku ke 1 = 1.0 suku ke 2 = 10.0 selisih = 9.0 suku ke 2 = 10.0 suku ke 3 = 50.5 selisih = 40.5 suku ke 3 = 50.5 suku ke 4 = 172.0 selisih = 121.5 suku ke 4 = 172.0 suku ke 5 = 445.375 selisih = 273.375 suku ke 5 = 445.375 suku ke 6 = 937.45 selisih = 492.07500000000005 suku ke 6 = 937.45 suku ke 7 = 1675.5625 selisih = 738.1125 suku ke 7 = 1675.5625 suku ke 8 = 2624.5642857142857 selisih = 949.0017857142857 suku ke 8 = 2624.5642857142857 suku ke 9 = 3692.1912946428574 selisih = 1067.6270089285717 suku ke 9 = 3692.1912946428574 suku ke 10 = 4759.818303571429 selisih = 1067.6270089285717 suku ke 10 = 4759.818303571429 suku ke 11 = 5720.682611607143 selisih = 960.8643080357142 suku ke 11 = 5720.682611607143 suku ke 12 = 6506.844318181818 selisih = 786.161706574675 suku ke 12 = 6506.844318181818 suku ke 13 = 7096.465598112825 selisih = 589.6212799310069 suku ke 13 = 7096.465598112825 suku ke 14 = 7504.6649457573685 selisih = 408.1993476445432 suku ke 14 = 7504.6649457573685 suku ke 15 = 7767.078812100289 selisih = 262.4138663429203 suku ke 15 = 7767.078812100289 suku ke 16 = 7924.527131906041 selisih = 157.44831980575236 suku ke 16 = 7924.527131906041 suku ke 17 = 8013.091811796777 selisih = 88.56467989073553 suku ke 17 = 8013.091811796777 suku ke 18 = 8059.978995268342 selisih = 46.88718347156555 suku ke 18 = 8059.978995268342 suku ke 19 = 8083.4225870041255 selisih = 23.44359173578323 suku ke 19 = 8083.4225870041255 suku ke 20 = 8094.527446247391 selisih = 11.10485924326531 suku ke 20 = 8094.527446247391 suku ke 21 = 8099.5246329068605 selisih = 4.997186659469662 suku ke 21 = 8099.5246329068605 suku ke 22 = 8101.6662843323475 selisih = 2.141651425486998 suku ke 22 = 8101.6662843323475 suku ke 23 = 8102.542414460956 selisih = 0.8761301286085654 suku ke 23 = 8102.542414460956 suku ke 24 = 8102.885247989542 selisih = 0.34283352858619764 suku ke 24 = 8102.885247989542 suku ke 25 = 8103.013810562762 selisih = 0.12856257321982412 suku ke 25 = 8103.013810562762 suku ke 26 = 8103.060093089121 selisih = 0.04628252635939134 suku ke 26 = 8103.060093089121 suku ke 27 = 8103.076113963631 selisih = 0.016020874509194982 suku ke 27 = 8103.076113963631 suku ke 28 = 8103.081454255133 selisih = 0.005340291502761829 suku ke 28 = 8103.081454255133 suku ke 29 = 8103.083170777402 selisih = 0.0017165222689072834 suku ke 29 = 8103.083170777402 suku ke 30 = 8103.08370349121 selisih = 0.0005327138078428106","title":"Hasil Output"},{"location":"MengukurJaral/","text":"Pengertian \u00b6 Disini kita akan belajar cara mengukur jarak data menggunakan beberapa cara atau metode Minkowski Distance \u00b6 Kelompk Minkowski diantaranya adalah Euclidean distance dan Manhattan distance, yang menjadi kasus khusus dari Minkowski distance. Minkowski distance dinyatakan dengan $$ d _ { \\operatorname { min } } = ( \\ sum _ { i = 1 } ^ { n } | x _ { i } - y _ { i } | ^ { m } ) ^ { \\frac { 1 } { m } } , m \\geq 1 $$ Manhattan distance \u00b6 Manhattan distance adalah kasus khsusu dari jarak Minkowski distance pada m = 1. Seperti Minkowski Distance, Manhattan distance sensitif terhadap outlier. BIla ukuran ini digunakan dalam algoritma clustering , bentuk cluster adalah hyper-rectangular. Ukuran ini didefinisikan dengan $$ d _ { \\operatorname { man } } = \\sum _ { i = 1 } ^ { n } \\left| x _ { i } - y _ { i } \\right| $$ implementasi \u00b6 silahkan implementasinya Disini disana lengkap dengan codingan dan outputannya MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"mengukur jarak data"},{"location":"MengukurJaral/#pengertian","text":"Disini kita akan belajar cara mengukur jarak data menggunakan beberapa cara atau metode","title":"Pengertian"},{"location":"MengukurJaral/#minkowski-distance","text":"Kelompk Minkowski diantaranya adalah Euclidean distance dan Manhattan distance, yang menjadi kasus khusus dari Minkowski distance. Minkowski distance dinyatakan dengan $$ d _ { \\operatorname { min } } = ( \\ sum _ { i = 1 } ^ { n } | x _ { i } - y _ { i } | ^ { m } ) ^ { \\frac { 1 } { m } } , m \\geq 1 $$","title":"Minkowski Distance"},{"location":"MengukurJaral/#manhattan-distance","text":"Manhattan distance adalah kasus khsusu dari jarak Minkowski distance pada m = 1. Seperti Minkowski Distance, Manhattan distance sensitif terhadap outlier. BIla ukuran ini digunakan dalam algoritma clustering , bentuk cluster adalah hyper-rectangular. Ukuran ini didefinisikan dengan $$ d _ { \\operatorname { man } } = \\sum _ { i = 1 } ^ { n } \\left| x _ { i } - y _ { i } \\right| $$","title":"Manhattan distance"},{"location":"MengukurJaral/#implementasi","text":"silahkan implementasinya Disini disana lengkap dengan codingan dan outputannya MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"implementasi"},{"location":"NumericalSolution/","text":"Numerical Solution of Algebraic and Transcendental Equation \u00b6 Sistem persaman aljabar dapat diuraikan seperti dibawah ini Persamaan transcendental : sin, cos, tan, Persamaan polynomial : a0 + a1x + a2x2 \u2026\u2026. + anxn + \u2026\u2026 Penyelesaian persamaan non linier \u00b6 Metode Tertutup \u00b6 Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka \u00b6 Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Method Bisection \u00b6 Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan langkah langkah Tentukan batas bawah (a) dan batas atas (b). Kemudian dihitung nilai tengah : $$ c = {(a+b)\\over 2} $$ Dari nilai c ini perlu dilakukan pengecekan keberadaan akar. Secara matematik, suatu range terdapat akar persamaan bila f(a) dan f(b) berlawanan tanda atau dituliskan : $$ f(a).f(b) <0 $$ Setelah diketahui di bagian mana terdapat akar, maka batas bawah dan batas atas diperbarui sesuai dengan range dari bagian yang mempunyai akar algoritma metode bisection 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Tentukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan 6.Hitung x = (a+b)/2 7.Hitung f(x) 8.Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) 9.Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 implementasi metode bisection dalam python \u00b6 def bisection ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Bisection method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = ( a_n + b_n ) / 2 f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Bisection method fails.\" ) return None return ( a_n + b_n ) / 2 f = lambda x : x ** 2 - 5 * x + 6 approx_phi = bisection ( f , 1 , 2.3 , 25 ) print ( approx_phi ) 1.9999999985098835 method Regula Falsi \u00b6 1.Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. 2.Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. 3.Dikenal dengan metode False Position 4.Metode ini juga merupakan penyempurna dari metode bisection algoritma method regula falsi Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : $$ c= {(f(b).a -f(a).b)\\over (f(b)-f(a))} $$ Hitung f(c)=f(x) \u200b Hitung error = |f(c)| \u200b Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) Akar persamaanya = c implementasi method regula falsi dalam python \u00b6 error = 0.01 a = 0 b = 2.1 def f ( x ): return x ** 2 - 5 * x + 6 def regulasi_falsi ( a , b ): i = 0 max_iter = 50 iteration = True while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a * abs ( f ( b )) + b * abs ( f ( a ))) / ( abs ( f ( a )) + abs ( f ( b ))) if f ( a ) * f ( x ) < 0 : b = x if f ( x ) * f ( b ) < 0 : a = x if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak di temukan akar' ) print ( 'x =' , x ) regulasi_falsi ( a , b ) x = 2.000000000174259 Metode Newton Raphson \u00b6 Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Prinsip Metode Newton Raphson Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. prosedur Menentukan x0 sebagai titik awal. Menarik garis lurus (misal garis P) yang menyinggung titik f(x0). Hal ini berakibat garis P memotong sumbu-x di titik x1. Ulangi langkah sebelumnya tapi sekarang x1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x1,x2,x3,...,,xn dengan xn yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya algoritma implementasi Metode Newton Raphson python \u00b6 def newton ( f , Df , x0 , epsilon , max_iter ): xn = x0 for n in range ( 0 , max_iter ): fxn = f ( xn ) if abs ( fxn ) < epsilon : print ( 'Found solution after' , n , 'iterations.' ) return xn Dfxn = Df ( xn ) if Dfxn == 0 : print ( 'Zero derivative. No solution found.' ) return None xn = xn - fxn / Dfxn print ( 'Exceeded maximum iterations. No solution found.' ) return None p = lambda x : x ** 2 - 5 * x + 6 Dp = lambda x : 2 * x - 5 approx = newton ( p , Dp , 1 , 1e-3 , 10 ) print ( approx ) Found solution after 4 iterations . 1.9999847409781035 Metode Secant \u00b6 \u25a0Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). \u25a0Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. \u25a0Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen \u25a0Modifikasi metode Newton Raphson dinamakan metode Secant. formula secant \u00b6 $$ y = \\frac{f(b) - f(a)}{b - a}(x - a) + f(a) $$ $$ 0 = \\frac{f(b) - f(a)}{b - a}(x - a) + f(a) $$ $$ x = a - f(a)\\frac{b - a}{f(b) - f(a)} $$ algoritma method secant \u00b6 \u25a0 Definisikan f(x) \u25a0 Definisikan toleransi error e dan iterasi maksimum (n) \u25a0 Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. \u25a0 Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 \u25a0 Untuk iterasi 1 s/d n x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) Akar persamaan adalah nilai x yang terakhir implementasi method secant pada python \u00b6 def secant ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Secant method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Secant method fails.\" ) return None return a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) p = lambda x : x ** 2 - 5 * x + 6 approx = secant ( p , 1 , 2.4 , 20 ) print ( approx ) 2.0000003178913373 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Numerical Solution"},{"location":"NumericalSolution/#numerical-solution-of-algebraic-and-transcendental-equation","text":"Sistem persaman aljabar dapat diuraikan seperti dibawah ini Persamaan transcendental : sin, cos, tan, Persamaan polynomial : a0 + a1x + a2x2 \u2026\u2026. + anxn + \u2026\u2026","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"NumericalSolution/#penyelesaian-persamaan-non-linier","text":"","title":"Penyelesaian persamaan non linier"},{"location":"NumericalSolution/#metode-tertutup","text":"Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi","title":"Metode Tertutup"},{"location":"NumericalSolution/#metode-terbuka","text":"Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant.","title":"Metode Terbuka"},{"location":"NumericalSolution/#method-bisection","text":"Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan langkah langkah Tentukan batas bawah (a) dan batas atas (b). Kemudian dihitung nilai tengah : $$ c = {(a+b)\\over 2} $$ Dari nilai c ini perlu dilakukan pengecekan keberadaan akar. Secara matematik, suatu range terdapat akar persamaan bila f(a) dan f(b) berlawanan tanda atau dituliskan : $$ f(a).f(b) <0 $$ Setelah diketahui di bagian mana terdapat akar, maka batas bawah dan batas atas diperbarui sesuai dengan range dari bagian yang mempunyai akar algoritma metode bisection 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Tentukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan 6.Hitung x = (a+b)/2 7.Hitung f(x) 8.Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) 9.Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6","title":"Method Bisection"},{"location":"NumericalSolution/#implementasi-metode-bisection-dalam-python","text":"def bisection ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Bisection method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = ( a_n + b_n ) / 2 f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Bisection method fails.\" ) return None return ( a_n + b_n ) / 2 f = lambda x : x ** 2 - 5 * x + 6 approx_phi = bisection ( f , 1 , 2.3 , 25 ) print ( approx_phi ) 1.9999999985098835","title":"implementasi metode bisection dalam python"},{"location":"NumericalSolution/#method-regula-falsi","text":"1.Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. 2.Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. 3.Dikenal dengan metode False Position 4.Metode ini juga merupakan penyempurna dari metode bisection algoritma method regula falsi Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : $$ c= {(f(b).a -f(a).b)\\over (f(b)-f(a))} $$ Hitung f(c)=f(x) \u200b Hitung error = |f(c)| \u200b Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) Akar persamaanya = c","title":"method Regula Falsi"},{"location":"NumericalSolution/#implementasi-method-regula-falsi-dalam-python","text":"error = 0.01 a = 0 b = 2.1 def f ( x ): return x ** 2 - 5 * x + 6 def regulasi_falsi ( a , b ): i = 0 max_iter = 50 iteration = True while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a * abs ( f ( b )) + b * abs ( f ( a ))) / ( abs ( f ( a )) + abs ( f ( b ))) if f ( a ) * f ( x ) < 0 : b = x if f ( x ) * f ( b ) < 0 : a = x if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak di temukan akar' ) print ( 'x =' , x ) regulasi_falsi ( a , b ) x = 2.000000000174259","title":"implementasi method regula falsi dalam python"},{"location":"NumericalSolution/#metode-newton-raphson","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Prinsip Metode Newton Raphson Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. prosedur Menentukan x0 sebagai titik awal. Menarik garis lurus (misal garis P) yang menyinggung titik f(x0). Hal ini berakibat garis P memotong sumbu-x di titik x1. Ulangi langkah sebelumnya tapi sekarang x1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x1,x2,x3,...,,xn dengan xn yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya algoritma","title":"Metode Newton Raphson"},{"location":"NumericalSolution/#implementasi-metode-newton-raphson-python","text":"def newton ( f , Df , x0 , epsilon , max_iter ): xn = x0 for n in range ( 0 , max_iter ): fxn = f ( xn ) if abs ( fxn ) < epsilon : print ( 'Found solution after' , n , 'iterations.' ) return xn Dfxn = Df ( xn ) if Dfxn == 0 : print ( 'Zero derivative. No solution found.' ) return None xn = xn - fxn / Dfxn print ( 'Exceeded maximum iterations. No solution found.' ) return None p = lambda x : x ** 2 - 5 * x + 6 Dp = lambda x : 2 * x - 5 approx = newton ( p , Dp , 1 , 1e-3 , 10 ) print ( approx ) Found solution after 4 iterations . 1.9999847409781035","title":"implementasi Metode Newton Raphson python"},{"location":"NumericalSolution/#metode-secant","text":"\u25a0Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). \u25a0Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. \u25a0Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen \u25a0Modifikasi metode Newton Raphson dinamakan metode Secant.","title":"Metode Secant"},{"location":"NumericalSolution/#formula-secant","text":"$$ y = \\frac{f(b) - f(a)}{b - a}(x - a) + f(a) $$ $$ 0 = \\frac{f(b) - f(a)}{b - a}(x - a) + f(a) $$ $$ x = a - f(a)\\frac{b - a}{f(b) - f(a)} $$","title":"formula secant"},{"location":"NumericalSolution/#algoritma-method-secant","text":"\u25a0 Definisikan f(x) \u25a0 Definisikan toleransi error e dan iterasi maksimum (n) \u25a0 Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. \u25a0 Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 \u25a0 Untuk iterasi 1 s/d n x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) Akar persamaan adalah nilai x yang terakhir","title":"algoritma method secant"},{"location":"NumericalSolution/#implementasi-method-secant-pada-python","text":"def secant ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Secant method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Secant method fails.\" ) return None return a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) p = lambda x : x ** 2 - 5 * x + 6 approx = secant ( p , 1 , 2.4 , 20 ) print ( approx ) 2.0000003178913373 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"implementasi method secant pada python"},{"location":"StatistikDesc/","text":"Ukuran Kecenderungan Terpusat \u00b6 Mean(Rata-Rata) \u00b6 Psada bagian ini, kami melihat cara untuk mengukur kecenderungan pusat data. Misalkan kita mempunyai atribut hasil pretest yang dinyatakan dengan atribut X. Misalkan x1,x2,...,xNx1,x2,...,xN menjadi himpunan nilai N yang diamati atau pengamatan untuk X. Di sini, nilai-nilai ini juga dapat disebut set data (untuk X). Jika kita merencanakan pengamatan untuk nilai pretest, di mana sebagian besar nilai berada? Ini memberi kita gambaran tentang kecenderungan pusat dari data. Ukuran kecenderungan pusat data ukurannya adalah rata-rata(mean), median, modus (mode), dan midrange. Atribut numerik yang paling umum dan efektif dari \"pusat\" dari set data adalah mean (aritmatika). Misalkan x1,x2,...,xNx1,x2,...,xN menjadi satu set nilai N atau pengamatan, Rata-rata dari nilai pretes dinyatakan dengan $$ \\bar{x}=\\frac{\\sum_{i=1}^{N} x_{i}}{N}=\\frac{x_{1}+x_{2}+\\cdots+x_{N}}{N} $$ `` Kadang-kadang, setiap nilai xixi dalam satu data dapat dikaitkan dengan bobot wiwi untuk i=1,..,Ni=1,..,N. Bobot tersebut mencerminkan signifikansi, kepentingan, atau frekuensi kejadian yang melekat pada masing masing nilai. Dalam hal ini, kita dapat menghitungnya dengan $$ \\overline{x}=\\frac{\\sum_{i=1}^{N} w_{i} x_{i}}{\\sum_{i=1}^{N} w_{i}}=\\frac{w_{1} x_{1}+w_{2} x_{2}+\\cdots+w_{N} x_{N}}{w_{1}+w_{2}+\\cdots+w_{N}} $$ Meskipun rata-rata adalah jumlah yang sangat berguna untuk menggambarkan kumpulan data, itu tidak selalu cara terbaik untuk mengukur pusat data. Masalah utama dengan mean adalah sensitivitasnya terhadap nilai ekstrim (mis., outlier). Bahkan beberapa nilai ekstrem saja dapat merusak mean. Misalnya, gaji rata-rata di suatu perusahaan mungkin sangat besar didorong oleh beberapa manajer bergaji tinggi. Demikian pula, nilai rata-rata kelas di ujian dapat rata-rata rendah karena beberapa ada beberap skor nilai saja yang sangat rendah. Untuk mengimbangi efek tersebut kita bisa menggunakan rata-rata yang dipangkas (trimmed mean), yang merupakan rata-rata yang diperoleh setelah memangkas nilai paling tinggi dan nilai yang paling rendah. Untuk contoh, kita dapat mengurutkan nilai gaji yang diamati kemudian menghapus 2% atas dan bawah nilai tersebut sebelum menghitung mean. Kita harus menghindari pemotongan bagian yang terlalu besar (seperti 20%) pada kedua ujungnya, karena hal ini dapat mengakibatkan hilangnya informasi yang berharga) Median (Nilai Tengah) \u00b6 Untuk data miring (asimetris), ukuran pusat data yang lebih baik adalah median, yang merupakan nilai tengah dalam satu set nilai data yang diurutkan. Ini adalah nilai yang memisahkan separuh data yang lebih tinggi dari data tersebut dan sebagian data yang lebih rendah dari data tersebut. Dalam probabilitas dan statistik, median umumnya berlaku untuk data numerik; namun, kami dapat memperluas konsep menjadi data ordinal. Misalkan kumpulan N data yang diberikan untuk atribut X diurutkan dalam urutan naik. Jika N ganjil, maka median adalah nilai tengah dari data yang ordinal. Jika N adalah genap, maka mediannya tidak unik; dihitung dengan rata rata dari nilai $$(\\frac{N}{2}+1) +(\\frac{N}{2}-1) $$ Namun pada data berkelompok, dengan data yang berbentuk kelas interval, kita tidak bisa langsung mengetahui nilai median jika kelas mediannya sudah diketahui dengan formula $$ M e=x_{i j}+\\left(\\frac{\\frac{n}{2}-f_{k i j}}{f_{i}}\\right) p $$ $$ \\begin{array}{l}{M e=\\text { median }} \\ {x_{i j}=\\text { batas bawah median }} \\ {n=\\text { jumlah data }} \\ {f_{k i j}=\\text { frekuensi kumulatif data di bawah kelas median }} \\ {f_{i}=\\text { frekuensi data pada kelas median }} \\ {p=\\text { panjang interval kelas }}\\end{array} $$ Rentang (Range), Quartil, and Rentang Interquartile \u00b6 \u00b6 Misalkan x1,x2,..xNx1,x2,..xN adalah sekumpulan pengamatan untuk atribut numerik, XX. Rentang adalah selisih antara nilai terbesar (maks ()) dan terkecil (min ()). Misalkan data untuk atribut X diurutkan dalam urutan naik.Bagilah data berdasarkan titik titik tertentu sehingga membagi distribusi data ukuran yang sama, seperti pada Gambar dibawah. Titik data ini disebut kuantil. 2-quantile adalah titik data yang membagi bagian bawah dan atas dari distribusi data. Ini sama dengan median. 4-kuantil adalah tiga titik data yang membagi distribusi data menjadi empat bagian yang sama; setiap bagian mewakili seperempat dari distribusi data. Ini lebih sering disebut sebagai kuartil. 100-kuantil lebih sering disebut sebagai persentil; mereka membagi distribusi data menjadi 100 data berukuran sama. Median, kuartil, dan persentil adalah bentuk kuantil yang paling banyak digunakan. Kuartil memberikan gambaran pusat distribus, penyebaran, dan bentuk distribusi. Kuartil satu, dilambangkan oleh Q1, adalah persentil ke-25. Nilai ini menunjukan 25% terendah dari data. Kuartil ketiga, dilambangkan oleh Q3, adalah persentil ke-75 - itu memisahkan data 75% dari terendah data (atau 25% dari tertinggi data. Kuartil kedua adalah persentil ke-50 atau median dari distribusi data. Variansi dan Standar Deviasi \u00b6 \u00b6 Variansi dan standar deviasi adalah ukuran penyebaran data. Nilai-nilai tersebut menunjukkan bagaimana penyebaran distribusi data. Standar Deviasi yang rendah berarti bahwa pengamatan data cenderung sangat dekat dengan rata-rata, sedangkan deviasi standar yang tinggi menunjukkan data tersebar di sejumlah nilai-nilai besar. Varian dari pengamatan $$ N, x_1, x_2, ..., x_N $$ untuk atribut numerik X adalah $$ \\sigma ^ { 2 } = \\frac { 1 } { N } \\sum _ { i = 1 } ^ { N } ( x _ { i } - \\overline { x } ) ^ { 2 } = ( \\frac { 1 } { N } \\sum _ { i = 1 } ^ { N } x _ { i } ^ { 2 } ) - \\overline { x } ^ { 2 } $$ Skewness \u00b6 \u00b6 Derajat distorsi dari kurva lonceng simetris atau distribusi normal. Ini mengukur kurangnya simetri dalam distribusi data Untuk menghitung derajat distorisi dapat menggunakan Koefisien Kemencengan Pearson yang diperoleh dengan menggunakan nilai selisih rata-rata dengan modus dibagi simpangan baku. Koefisien Kemencengan Pearson dirumuskan sebagai berikut $$ s k=\\frac{\\overline{X}-M o}{s} $$ dengan $$ \\overline{X}-M o \\approx 3(\\overline{X}-M e) $$ maka $$ s k \\approx \\frac{3(\\overline{X}-M e)}{s} $$ implementasi \u00b6 \u00b6 silahkan download filenya disini import pandas as pd from scipy import stats df = pd . read_csv ( 'data.csv' , sep = ';' ) temp = { 'stats' :[ 'Min' , 'Max' , 'Mean' , 'Standard Deviasi' , 'Variasi' , 'Skewnes' , 'Quartile1' , 'Quartile2' , 'Quartile3' , 'Median' , 'Modus' ]} for i in df . columns : temp [ i ] = [ df [ i ] . min (), df [ i ] . max (), df [ i ] . mean (), df [ i ] . std (), df [ i ] . var (), df [ i ] . skew (), df [ i ] . quantile ( 0.25 ), df [ i ] . quantile ( 0.5 ), df [ i ] . quantile ( 0.75 ), df [ i ] . mean (), stats . mode ( df [ i ]) . mode [ 0 ]] file = pd . DataFrame ( temp ) file . style . hide_index () stats x1 x2 Min 2 500 Max 3 1000 Mean 2.66667 700 Standard Deviasi 0.57735 264.575 Variasi 0.333333 70000 Skewness -1.73205 1.45786 Quartile 1 2.5 550 Quartile 2 3 600 Quartile 3 3 800 Median 2.66667 700 Modus 3 500 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"statistik deskriptif"},{"location":"StatistikDesc/#ukuran-kecenderungan-terpusat","text":"","title":"Ukuran Kecenderungan Terpusat"},{"location":"StatistikDesc/#meanrata-rata","text":"Psada bagian ini, kami melihat cara untuk mengukur kecenderungan pusat data. Misalkan kita mempunyai atribut hasil pretest yang dinyatakan dengan atribut X. Misalkan x1,x2,...,xNx1,x2,...,xN menjadi himpunan nilai N yang diamati atau pengamatan untuk X. Di sini, nilai-nilai ini juga dapat disebut set data (untuk X). Jika kita merencanakan pengamatan untuk nilai pretest, di mana sebagian besar nilai berada? Ini memberi kita gambaran tentang kecenderungan pusat dari data. Ukuran kecenderungan pusat data ukurannya adalah rata-rata(mean), median, modus (mode), dan midrange. Atribut numerik yang paling umum dan efektif dari \"pusat\" dari set data adalah mean (aritmatika). Misalkan x1,x2,...,xNx1,x2,...,xN menjadi satu set nilai N atau pengamatan, Rata-rata dari nilai pretes dinyatakan dengan $$ \\bar{x}=\\frac{\\sum_{i=1}^{N} x_{i}}{N}=\\frac{x_{1}+x_{2}+\\cdots+x_{N}}{N} $$ `` Kadang-kadang, setiap nilai xixi dalam satu data dapat dikaitkan dengan bobot wiwi untuk i=1,..,Ni=1,..,N. Bobot tersebut mencerminkan signifikansi, kepentingan, atau frekuensi kejadian yang melekat pada masing masing nilai. Dalam hal ini, kita dapat menghitungnya dengan $$ \\overline{x}=\\frac{\\sum_{i=1}^{N} w_{i} x_{i}}{\\sum_{i=1}^{N} w_{i}}=\\frac{w_{1} x_{1}+w_{2} x_{2}+\\cdots+w_{N} x_{N}}{w_{1}+w_{2}+\\cdots+w_{N}} $$ Meskipun rata-rata adalah jumlah yang sangat berguna untuk menggambarkan kumpulan data, itu tidak selalu cara terbaik untuk mengukur pusat data. Masalah utama dengan mean adalah sensitivitasnya terhadap nilai ekstrim (mis., outlier). Bahkan beberapa nilai ekstrem saja dapat merusak mean. Misalnya, gaji rata-rata di suatu perusahaan mungkin sangat besar didorong oleh beberapa manajer bergaji tinggi. Demikian pula, nilai rata-rata kelas di ujian dapat rata-rata rendah karena beberapa ada beberap skor nilai saja yang sangat rendah. Untuk mengimbangi efek tersebut kita bisa menggunakan rata-rata yang dipangkas (trimmed mean), yang merupakan rata-rata yang diperoleh setelah memangkas nilai paling tinggi dan nilai yang paling rendah. Untuk contoh, kita dapat mengurutkan nilai gaji yang diamati kemudian menghapus 2% atas dan bawah nilai tersebut sebelum menghitung mean. Kita harus menghindari pemotongan bagian yang terlalu besar (seperti 20%) pada kedua ujungnya, karena hal ini dapat mengakibatkan hilangnya informasi yang berharga)","title":"Mean(Rata-Rata)"},{"location":"StatistikDesc/#median-nilai-tengah","text":"Untuk data miring (asimetris), ukuran pusat data yang lebih baik adalah median, yang merupakan nilai tengah dalam satu set nilai data yang diurutkan. Ini adalah nilai yang memisahkan separuh data yang lebih tinggi dari data tersebut dan sebagian data yang lebih rendah dari data tersebut. Dalam probabilitas dan statistik, median umumnya berlaku untuk data numerik; namun, kami dapat memperluas konsep menjadi data ordinal. Misalkan kumpulan N data yang diberikan untuk atribut X diurutkan dalam urutan naik. Jika N ganjil, maka median adalah nilai tengah dari data yang ordinal. Jika N adalah genap, maka mediannya tidak unik; dihitung dengan rata rata dari nilai $$(\\frac{N}{2}+1) +(\\frac{N}{2}-1) $$ Namun pada data berkelompok, dengan data yang berbentuk kelas interval, kita tidak bisa langsung mengetahui nilai median jika kelas mediannya sudah diketahui dengan formula $$ M e=x_{i j}+\\left(\\frac{\\frac{n}{2}-f_{k i j}}{f_{i}}\\right) p $$ $$ \\begin{array}{l}{M e=\\text { median }} \\ {x_{i j}=\\text { batas bawah median }} \\ {n=\\text { jumlah data }} \\ {f_{k i j}=\\text { frekuensi kumulatif data di bawah kelas median }} \\ {f_{i}=\\text { frekuensi data pada kelas median }} \\ {p=\\text { panjang interval kelas }}\\end{array} $$","title":"Median (Nilai Tengah)"},{"location":"StatistikDesc/#rentang-range-quartil-and-rentang-interquartile","text":"Misalkan x1,x2,..xNx1,x2,..xN adalah sekumpulan pengamatan untuk atribut numerik, XX. Rentang adalah selisih antara nilai terbesar (maks ()) dan terkecil (min ()). Misalkan data untuk atribut X diurutkan dalam urutan naik.Bagilah data berdasarkan titik titik tertentu sehingga membagi distribusi data ukuran yang sama, seperti pada Gambar dibawah. Titik data ini disebut kuantil. 2-quantile adalah titik data yang membagi bagian bawah dan atas dari distribusi data. Ini sama dengan median. 4-kuantil adalah tiga titik data yang membagi distribusi data menjadi empat bagian yang sama; setiap bagian mewakili seperempat dari distribusi data. Ini lebih sering disebut sebagai kuartil. 100-kuantil lebih sering disebut sebagai persentil; mereka membagi distribusi data menjadi 100 data berukuran sama. Median, kuartil, dan persentil adalah bentuk kuantil yang paling banyak digunakan. Kuartil memberikan gambaran pusat distribus, penyebaran, dan bentuk distribusi. Kuartil satu, dilambangkan oleh Q1, adalah persentil ke-25. Nilai ini menunjukan 25% terendah dari data. Kuartil ketiga, dilambangkan oleh Q3, adalah persentil ke-75 - itu memisahkan data 75% dari terendah data (atau 25% dari tertinggi data. Kuartil kedua adalah persentil ke-50 atau median dari distribusi data.","title":"Rentang (Range), Quartil, and Rentang Interquartile\u00b6"},{"location":"StatistikDesc/#variansi-dan-standar-deviasi","text":"Variansi dan standar deviasi adalah ukuran penyebaran data. Nilai-nilai tersebut menunjukkan bagaimana penyebaran distribusi data. Standar Deviasi yang rendah berarti bahwa pengamatan data cenderung sangat dekat dengan rata-rata, sedangkan deviasi standar yang tinggi menunjukkan data tersebar di sejumlah nilai-nilai besar. Varian dari pengamatan $$ N, x_1, x_2, ..., x_N $$ untuk atribut numerik X adalah $$ \\sigma ^ { 2 } = \\frac { 1 } { N } \\sum _ { i = 1 } ^ { N } ( x _ { i } - \\overline { x } ) ^ { 2 } = ( \\frac { 1 } { N } \\sum _ { i = 1 } ^ { N } x _ { i } ^ { 2 } ) - \\overline { x } ^ { 2 } $$","title":"Variansi dan Standar Deviasi\u00b6"},{"location":"StatistikDesc/#skewness","text":"Derajat distorsi dari kurva lonceng simetris atau distribusi normal. Ini mengukur kurangnya simetri dalam distribusi data Untuk menghitung derajat distorisi dapat menggunakan Koefisien Kemencengan Pearson yang diperoleh dengan menggunakan nilai selisih rata-rata dengan modus dibagi simpangan baku. Koefisien Kemencengan Pearson dirumuskan sebagai berikut $$ s k=\\frac{\\overline{X}-M o}{s} $$ dengan $$ \\overline{X}-M o \\approx 3(\\overline{X}-M e) $$ maka $$ s k \\approx \\frac{3(\\overline{X}-M e)}{s} $$","title":"Skewness\u00b6"},{"location":"StatistikDesc/#implementasi","text":"silahkan download filenya disini import pandas as pd from scipy import stats df = pd . read_csv ( 'data.csv' , sep = ';' ) temp = { 'stats' :[ 'Min' , 'Max' , 'Mean' , 'Standard Deviasi' , 'Variasi' , 'Skewnes' , 'Quartile1' , 'Quartile2' , 'Quartile3' , 'Median' , 'Modus' ]} for i in df . columns : temp [ i ] = [ df [ i ] . min (), df [ i ] . max (), df [ i ] . mean (), df [ i ] . std (), df [ i ] . var (), df [ i ] . skew (), df [ i ] . quantile ( 0.25 ), df [ i ] . quantile ( 0.5 ), df [ i ] . quantile ( 0.75 ), df [ i ] . mean (), stats . mode ( df [ i ]) . mode [ 0 ]] file = pd . DataFrame ( temp ) file . style . hide_index () stats x1 x2 Min 2 500 Max 3 1000 Mean 2.66667 700 Standard Deviasi 0.57735 264.575 Variasi 0.333333 70000 Skewness -1.73205 1.45786 Quartile 1 2.5 550 Quartile 2 3 600 Quartile 3 3 800 Median 2.66667 700 Modus 3 500 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"implementasi\u00b6"},{"location":"Tugas3/","text":"Eliminasi Gauss Jordan \u00b6 \u200b Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. \u200b Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan \u00b6 \u00b6 Listing Program \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u00b6 Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program \u00b6 from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel \u00b6 Listing Program \u00b6 def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Eliminasi Gauss Jordan"},{"location":"Tugas3/#eliminasi-gauss-jordan","text":"\u200b Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. \u200b Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan"},{"location":"Tugas3/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan"},{"location":"Tugas3/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program"},{"location":"Tugas3/#eliminasi-gauss-jacobi","text":"Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi"},{"location":"Tugas3/#listing-program_1","text":"from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program"},{"location":"Tugas3/#program-gauss-seidel","text":"","title":"Program Gauss Seidel"},{"location":"Tugas3/#listing-program_2","text":"def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Listing Program"},{"location":"Weighted K-Nearest Neighbor/","text":"Weighted K-Nearest Neighbor \u00b6 klasifikasi data menggunakan metode W-KNN dengan sampel percobaan sebagai berikut: berikut adalah data yang diambil secara acak dari data iris sebanyak 100 sepal_length sepal_width petal_length petal_width species Training data sepal_length as A sepal_width as B petal_length as C petal_width as D species 6,9 3,1 5,1 2,3 virginica 6,7 3 5 1,7 versicolor 6,9 3,1 4,9 1,5 versicolor 6,7 3 5,2 2,3 virginica 6,7 3,1 4,7 1,5 versicolor 6,5 3,2 5,1 2 virginica 6,9 3,1 5,4 2,1 virginica 7 3,2 4,7 1,4 versicolor 6,5 3 5,2 2 virginica 6,8 2,8 4,8 1,4 versicolor 6,8 3 5,5 2,1 virginica 6,5 2,8 4,6 1,5 versicolor 6,7 3,1 4,4 1,4 versicolor 6,3 2,7 4,9 1,8 virginica 6,6 3 4,4 1,4 versicolor 6,6 2,9 4,6 1,3 versicolor 6,4 2,7 5,3 1,9 virginica 6,2 2,8 4,8 1,8 virginica 6,4 3,2 4,5 1,5 versicolor 6,4 3,2 5,3 2,3 virginica 6,3 3,3 4,7 1,6 versicolor 6,5 3 5,5 1,8 virginica 6,3 2,5 5 1,9 virginica 6,1 3 4,9 1,8 virginica 6,3 2,8 5,1 1,5 virginica 6,7 3,1 5,6 2,4 virginica 6,4 3,1 5,5 1,8 virginica 6,9 3,2 5,7 2,3 virginica 6,3 2,5 4,9 1,5 versicolor 6,7 3,3 5,7 2,1 virginica 6 3 4,8 1,8 virginica 6,4 2,8 5,6 2,1 virginica 6,4 2,8 5,6 2,2 virginica 6,4 2,9 4,3 1,3 versicolor 6,3 2,9 5,6 1,8 virginica 6,1 2,9 4,7 1,4 versicolor 7,2 3 5,8 1,6 virginica 6,1 3 4,6 1,4 versicolor 7,1 3 5,9 2,1 virginica 6,7 3,3 5,7 2,5 virginica 6,2 3,4 5,4 2,3 virginica 5,9 3,2 4,8 1,8 versicolor 6,5 3 5,8 2,2 virginica 5,9 3 5,1 1,8 virginica 6 2,7 5,1 1,6 versicolor 6 2,9 4,5 1,5 versicolor 6,7 2,5 5,8 1,8 virginica 6,8 3,2 5,9 2,3 virginica 6,2 2,9 4,3 1,3 versicolor 6 3,4 4,5 1,6 versicolor 6,3 3,4 5,6 2,4 virginica 6,1 2,8 4,7 1,2 versicolor 7,2 3,2 6 1,8 virginica 6,2 2,2 4,5 1,5 versicolor 6,3 2,3 4,4 1,3 versicolor 5,8 2,7 5,1 1,9 virginica 5,8 2,7 5,1 1,9 virginica 5,8 2,8 5,1 2,4 virginica 5,9 3 4,2 1,5 versicolor 7,4 2,8 6,1 1,9 virginica 6 2,2 5 1,5 virginica 6,1 2,6 5,6 1,4 virginica 5,7 2,5 5 2 virginica 6,1 2,8 4 1,3 versicolor 5,6 2,8 4,9 2 virginica 7,7 3 6,1 2,3 virginica 6,3 3,3 6 2,5 virginica 5,6 3 4,5 1,5 versicolor 5,7 2,8 4,5 1,3 versicolor 7,2 3,6 6,1 2,5 virginica 7,3 2,9 6,3 1,8 virginica 5,7 2,9 4,2 1,3 versicolor 5,7 3 4,2 1,2 versicolor 5,7 2,8 4,1 1,3 versicolor 5,8 2,6 4 1,2 versicolor 5,4 3 4,5 1,5 versicolor 5,6 2,7 4,2 1,3 versicolor 5,6 3 4,1 1,3 versicolor 5,8 2,7 3,9 1,2 versicolor 5,8 2,7 4,1 1 versicolor 5,5 2,6 4,4 1,2 versicolor 6 2,2 4 1 versicolor 7,6 3 6,6 2,1 virginica 5,5 2,5 4 1,3 versicolor 5,6 2,5 3,9 1,1 versicolor 5,5 2,3 4 1,3 versicolor 5,6 2,9 3,6 1,3 versicolor 7,9 3,8 6,4 2 virginica 7,7 2,8 6,7 2 virginica 5,5 2,4 3,8 1,1 versicolor 5,2 2,7 3,9 1,4 versicolor 5,7 2,6 3,5 1 versicolor 7,7 3,8 6,7 2,2 virginica 5,5 2,4 3,7 1 versicolor 4,9 2,5 4,5 1,7 virginica 7,7 2,6 6,9 2,3 virginica 5 2 3,5 1 versicolor 5 2,3 3,3 1 versicolor 5,1 2,5 3 1,1 versicolor 4,9 2,4 3,3 1 versicolor 5,7 3,8 1,7 0,3 setosa 5,1 3,8 1,9 0,4 setosa 5,4 3,9 1,7 0,4 setosa 5,1 3,3 1,7 0,5 setosa 5,4 3,4 1,7 0,2 setosa 5,4 3,4 1,5 0,4 setosa 5 3,5 1,6 0,6 setosa 4,8 3,4 1,9 0,2 setosa 5 3,4 1,6 0,4 setosa 5,7 4,4 1,5 0,4 setosa 5,4 3,7 1,5 0,2 setosa 5 3 1,6 0,2 setosa 5,3 3,7 1,5 0,2 setosa 5,1 3,7 1,5 0,4 setosa 5,2 3,5 1,5 0,2 setosa 5,1 3,8 1,6 0,2 setosa 5,1 3,4 1,5 0,2 setosa 5,5 3,5 1,3 0,2 setosa 5,1 3,8 1,5 0,3 setosa 5,4 3,9 1,3 0,4 setosa 5,2 3,4 1,4 0,2 setosa 5 3,4 1,5 0,2 setosa 5,1 3,5 1,4 0,3 setosa 4,8 3,1 1,6 0,2 setosa 4,8 3,4 1,6 0,2 setosa 5,5 4,2 1,4 0,2 setosa 5,8 4 1,2 0,2 setosa 5,1 3,5 1,4 0,2 setosa 4,7 3,2 1,6 0,2 setosa 5 3,3 1,4 0,2 setosa 4,9 3,1 1,5 0,1 setosa 4,9 3,1 1,5 0,1 setosa 4,9 3,1 1,5 0,1 setosa 5,2 4,1 1,5 0,1 setosa 5 3,6 1,4 0,2 setosa 4,9 3 1,4 0,2 setosa 4,8 3 1,4 0,3 setosa 5 3,5 1,3 0,3 setosa 4,6 3,1 1,5 0,2 setosa 4,8 3 1,4 0,1 setosa 5 3,2 1,2 0,2 setosa 4,6 3,4 1,4 0,3 setosa 4,6 3,2 1,4 0,2 setosa 4,7 3,2 1,3 0,2 setosa 4,4 2,9 1,4 0,2 setosa 4,5 2,3 1,3 0,3 setosa 4,4 3 1,3 0,2 setosa 4,4 3,2 1,3 0,2 setosa 4,6 3,6 1 0,2 setosa 4,3 3 1,1 0,1 setosa menghitung jarak \u00b6 sepal_length as A sepal_width as B petal_length as C petal_width as D species (A-S1)^2 (B-S2)^2 (C-S3)^2 (D-S4)^2 SQRT(D) 6,9 3,1 5,1 2,3 virginica 3,6 1,2 0,4 0,6 2,4 6,7 3 5 1,7 versicolor 2,9 1,0 0,3 0,0 2,0 6,9 3,1 4,9 1,5 versicolor 3,6 1,2 0,2 0,0 2,2 6,7 3 5,2 2,3 virginica 2,9 1,0 0,5 0,6 2,2 6,7 3,1 4,7 1,5 versicolor 2,9 1,2 0,0 0,0 2,0 6,5 3,2 5,1 2 virginica 2,3 1,4 0,4 0,3 2,1 6,9 3,1 5,4 2,1 virginica 3,6 1,2 0,8 0,4 2,4 7 3,2 4,7 1,4 versicolor 4,0 1,4 0,0 0,0 2,3 6,5 3 5,2 2 virginica 2,3 1,0 0,5 0,3 2,0 6,8 2,8 4,8 1,4 versicolor 3,2 0,6 0,1 0,0 2,0 6,8 3 5,5 2,1 virginica 3,2 1,0 1,0 0,4 2,4 6,5 2,8 4,6 1,5 versicolor 2,3 0,6 0,0 0,0 1,7 6,7 3,1 4,4 1,4 versicolor 2,9 1,2 0,0 0,0 2,0 6,3 2,7 4,9 1,8 virginica 1,7 0,5 0,2 0,1 1,6 6,6 3 4,4 1,4 versicolor 2,6 1,0 0,0 0,0 1,9 6,6 2,9 4,6 1,3 versicolor 2,6 0,8 0,0 0,0 1,8 6,4 2,7 5,3 1,9 virginica 2,0 0,5 0,6 0,2 1,8 6,2 2,8 4,8 1,8 virginica 1,4 0,6 0,1 0,1 1,5 6,4 3,2 4,5 1,5 versicolor 2,0 1,4 0,0 0,0 1,8 6,4 3,2 5,3 2,3 virginica 2,0 1,4 0,6 0,6 2,2 6,3 3,3 4,7 1,6 versicolor 1,7 1,7 0,0 0,0 1,9 6,5 3 5,5 1,8 virginica 2,3 1,0 1,0 0,1 2,1 6,3 2,5 5 1,9 virginica 1,7 0,3 0,3 0,2 1,5 6,1 3 4,9 1,8 virginica 1,2 1,0 0,2 0,1 1,6 6,3 2,8 5,1 1,5 virginica 1,7 0,6 0,4 0,0 1,6 6,7 3,1 5,6 2,4 virginica 2,9 1,2 1,2 0,8 2,5 6,4 3,1 5,5 1,8 virginica 2,0 1,2 1,0 0,1 2,1 6,9 3,2 5,7 2,3 virginica 3,6 1,4 1,4 0,6 2,7 6,3 2,5 4,9 1,5 versicolor 1,7 0,3 0,2 0,0 1,4 6,7 3,3 5,7 2,1 virginica 2,9 1,7 1,4 0,4 2,5 6 3 4,8 1,8 virginica 1,0 1,0 0,1 0,1 1,5 6,4 2,8 5,6 2,1 virginica 2,0 0,6 1,2 0,4 2,0 6,4 2,8 5,6 2,2 virginica 2,0 0,6 1,2 0,5 2,1 6,4 2,9 4,3 1,3 versicolor 2,0 0,8 0,0 0,0 1,7 6,3 2,9 5,6 1,8 virginica 1,7 0,8 1,2 0,1 1,9 6,1 2,9 4,7 1,4 versicolor 1,2 0,8 0,0 0,0 1,4 7,2 3 5,8 1,6 virginica 4,8 1,0 1,7 0,0 2,7 6,1 3 4,6 1,4 versicolor 1,2 1,0 0,0 0,0 1,5 7,1 3 5,9 2,1 virginica 4,4 1,0 2,0 0,4 2,8 6,7 3,3 5,7 2,5 virginica 2,9 1,7 1,4 1,0 2,6 6,2 3,4 5,4 2,3 virginica 1,4 2,0 0,8 0,6 2,2 5,9 3,2 4,8 1,8 versicolor 0,8 1,4 0,1 0,1 1,6 6,5 3 5,8 2,2 virginica 2,3 1,0 1,7 0,5 2,3 5,9 3 5,1 1,8 virginica 0,8 1,0 0,4 0,1 1,5 6 2,7 5,1 1,6 versicolor 1,0 0,5 0,4 0,0 1,4 6 2,9 4,5 1,5 versicolor 1,0 0,8 0,0 0,0 1,3 6,7 2,5 5,8 1,8 virginica 2,9 0,3 1,7 0,1 2,2 6,8 3,2 5,9 2,3 virginica 3,2 1,4 2,0 0,6 2,7 6,2 2,9 4,3 1,3 versicolor 1,4 0,8 0,0 0,0 1,5 6 3,4 4,5 1,6 versicolor 1,0 2,0 0,0 0,0 1,7 6,3 3,4 5,6 2,4 virginica 1,7 2,0 1,2 0,8 2,4 6,1 2,8 4,7 1,2 versicolor 1,2 0,6 0,0 0,1 1,4 7,2 3,2 6 1,8 virginica 4,8 1,4 2,3 0,1 2,9 6,2 2,2 4,5 1,5 versicolor 1,4 0,0 0,0 0,0 1,2 6,3 2,3 4,4 1,3 versicolor 1,7 0,1 0,0 0,0 1,4 5,8 2,7 5,1 1,9 virginica 0,6 0,5 0,4 0,2 1,3 5,8 2,7 5,1 1,9 virginica 0,6 0,5 0,4 0,2 1,3 5,8 2,8 5,1 2,4 virginica 0,6 0,6 0,4 0,8 1,6 5,9 3 4,2 1,5 versicolor 0,8 1,0 0,1 0,0 1,4 7,4 2,8 6,1 1,9 virginica 5,8 0,6 2,6 0,2 3,0 6 2,2 5 1,5 virginica 1,0 0,0 0,3 0,0 1,1 6,1 2,6 5,6 1,4 virginica 1,2 0,4 1,2 0,0 1,7 5,7 2,5 5 2 virginica 0,5 0,3 0,3 0,3 1,1 6,1 2,8 4 1,3 versicolor 1,2 0,6 0,3 0,0 1,5 5,6 2,8 4,9 2 virginica 0,4 0,6 0,2 0,3 1,2 7,7 3 6,1 2,3 virginica 7,3 1,0 2,6 0,6 3,4 6,3 3,3 6 2,5 virginica 1,7 1,7 2,3 1,0 2,6 5,6 3 4,5 1,5 versicolor 0,4 1,0 0,0 0,0 1,2 5,7 2,8 4,5 1,3 versicolor 0,5 0,6 0,0 0,0 1,1 7,2 3,6 6,1 2,5 virginica 4,8 2,6 2,6 1,0 3,3 7,3 2,9 6,3 1,8 virginica 5,3 0,8 3,2 0,1 3,1 5,7 2,9 4,2 1,3 versicolor 0,5 0,8 0,1 0,0 1,2 5,7 3 4,2 1,2 versicolor 0,5 1,0 0,1 0,1 1,3 5,7 2,8 4,1 1,3 versicolor 0,5 0,6 0,2 0,0 1,2 5,8 2,6 4 1,2 versicolor 0,6 0,4 0,3 0,1 1,2 5,4 3 4,5 1,5 versicolor 0,2 1,0 0,0 0,0 1,1 5,6 2,7 4,2 1,3 versicolor 0,4 0,5 0,1 0,0 1,0 5,6 3 4,1 1,3 versicolor 0,4 1,0 0,2 0,0 1,2 5,8 2,7 3,9 1,2 versicolor 0,6 0,5 0,4 0,1 1,3 5,8 2,7 4,1 1 versicolor 0,6 0,5 0,2 0,3 1,2 5,5 2,6 4,4 1,2 versicolor 0,3 0,4 0,0 0,1 0,8 6 2,2 4 1 versicolor 1,0 0,0 0,3 0,3 1,2 7,6 3 6,6 2,1 virginica 6,8 1,0 4,4 0,4 3,5 5,5 2,5 4 1,3 versicolor 0,3 0,3 0,3 0,0 0,9 5,6 2,5 3,9 1,1 versicolor 0,4 0,3 0,4 0,2 1,1 5,5 2,3 4 1,3 versicolor 0,3 0,1 0,3 0,0 0,8 5,6 2,9 3,6 1,3 versicolor 0,4 0,8 0,8 0,0 1,4 7,9 3,8 6,4 2 virginica 8,4 3,2 3,6 0,3 3,9 7,7 2,8 6,7 2 virginica 7,3 0,6 4,8 0,3 3,6 5,5 2,4 3,8 1,1 versicolor 0,3 0,2 0,5 0,2 1,0 5,2 2,7 3,9 1,4 versicolor 0,0 0,5 0,4 0,0 0,9 5,7 2,6 3,5 1 versicolor 0,5 0,4 1,0 0,3 1,4 7,7 3,8 6,7 2,2 virginica 7,3 3,2 4,8 0,5 4,0 5,5 2,4 3,7 1 versicolor 0,3 0,2 0,6 0,3 1,1 4,9 2,5 4,5 1,7 virginica 0,0 0,3 0,0 0,0 0,5 7,7 2,6 6,9 2,3 virginica 7,3 0,4 5,8 0,6 3,7 5 2 3,5 1 versicolor 0,0 0,0 1,0 0,3 1,1 5 2,3 3,3 1 versicolor 0,0 0,1 1,4 0,3 1,3 5,1 2,5 3 1,1 versicolor 0,0 0,3 2,3 0,2 1,6 4,9 2,4 3,3 1 versicolor 0,0 0,2 1,4 0,3 1,4 5,7 3,8 1,7 0,3 setosa 0,5 3,2 7,8 1,4 3,6 5,1 3,8 1,9 0,4 setosa 0,0 3,2 6,8 1,2 3,3 5,4 3,9 1,7 0,4 setosa 0,2 3,6 7,8 1,2 3,6 5,1 3,3 1,7 0,5 setosa 0,0 1,7 7,8 1,0 3,2 5,4 3,4 1,7 0,2 setosa 0,2 2,0 7,8 1,7 3,4 5,4 3,4 1,5 0,4 setosa 0,2 2,0 9,0 1,2 3,5 5 3,5 1,6 0,6 setosa 0,0 2,3 8,4 0,8 3,4 4,8 3,4 1,9 0,2 setosa 0,0 2,0 6,8 1,7 3,2 5 3,4 1,6 0,4 setosa 0,0 2,0 8,4 1,2 3,4 5,7 4,4 1,5 0,4 setosa 0,5 5,8 9,0 1,2 4,1 5,4 3,7 1,5 0,2 setosa 0,2 2,9 9,0 1,7 3,7 5 3 1,6 0,2 setosa 0,0 1,0 8,4 1,7 3,3 5,3 3,7 1,5 0,2 setosa 0,1 2,9 9,0 1,7 3,7 5,1 3,7 1,5 0,4 setosa 0,0 2,9 9,0 1,2 3,6 5,2 3,5 1,5 0,2 setosa 0,0 2,3 9,0 1,7 3,6 5,1 3,8 1,6 0,2 setosa 0,0 3,2 8,4 1,7 3,7 5,1 3,4 1,5 0,2 setosa 0,0 2,0 9,0 1,7 3,6 5,5 3,5 1,3 0,2 setosa 0,3 2,3 10,2 1,7 3,8 5,1 3,8 1,5 0,3 setosa 0,0 3,2 9,0 1,4 3,7 5,4 3,9 1,3 0,4 setosa 0,2 3,6 10,2 1,2 3,9 5,2 3,4 1,4 0,2 setosa 0,0 2,0 9,6 1,7 3,6 5 3,4 1,5 0,2 setosa 0,0 2,0 9,0 1,7 3,6 5,1 3,5 1,4 0,3 setosa 0,0 2,3 9,6 1,4 3,6 4,8 3,1 1,6 0,2 setosa 0,0 1,2 8,4 1,7 3,4 4,8 3,4 1,6 0,2 setosa 0,0 2,0 8,4 1,7 3,5 5,5 4,2 1,4 0,2 setosa 0,3 4,8 9,6 1,7 4,0 5,8 4 1,2 0,2 setosa 0,6 4,0 10,9 1,7 4,1 5,1 3,5 1,4 0,2 setosa 0,0 2,3 9,6 1,7 3,7 4,7 3,2 1,6 0,2 setosa 0,1 1,4 8,4 1,7 3,4 5 3,3 1,4 0,2 setosa 0,0 1,7 9,6 1,7 3,6 4,9 3,1 1,5 0,1 setosa 0,0 1,2 9,0 2,0 3,5 4,9 3,1 1,5 0,1 setosa 0,0 1,2 9,0 2,0 3,5 4,9 3,1 1,5 0,1 setosa 0,0 1,2 9,0 2,0 3,5 5,2 4,1 1,5 0,1 setosa 0,0 4,4 9,0 2,0 3,9 5 3,6 1,4 0,2 setosa 0,0 2,6 9,6 1,7 3,7 4,9 3 1,4 0,2 setosa 0,0 1,0 9,6 1,7 3,5 4,8 3 1,4 0,3 setosa 0,0 1,0 9,6 1,4 3,5 5 3,5 1,3 0,3 setosa 0,0 2,3 10,2 1,4 3,7 4,6 3,1 1,5 0,2 setosa 0,2 1,2 9,0 1,7 3,5 4,8 3 1,4 0,1 setosa 0,0 1,0 9,6 2,0 3,6 5 3,2 1,2 0,2 setosa 0,0 1,4 10,9 1,7 3,7 4,6 3,4 1,4 0,3 setosa 0,2 2,0 9,6 1,4 3,6 4,6 3,2 1,4 0,2 setosa 0,2 1,4 9,6 1,7 3,6 4,7 3,2 1,3 0,2 setosa 0,1 1,4 10,2 1,7 3,7 4,4 2,9 1,4 0,2 setosa 0,4 0,8 9,6 1,7 3,5 4,5 2,3 1,3 0,3 setosa 0,3 0,1 10,2 1,4 3,5 4,4 3 1,3 0,2 setosa 0,4 1,0 10,2 1,7 3,6 4,4 3,2 1,3 0,2 setosa 0,4 1,4 10,2 1,7 3,7 4,6 3,6 1 0,2 setosa 0,2 2,6 12,3 1,7 4,1 4,3 3 1,1 0,1 setosa 0,5 1,0 11,6 2,0 3,9 dari jarak diatas kita bisa mengambil sampel mengetahui data yang akan dicari seperti contoh soal berikut : sepal_length sepal_width petal_length petal_width species Sampel data 5 2 4,5 1,5 ? dan diketahui hasilnya sebagai berikut : K=5 D 1/D Setosa versicolor virginica 0,5 2 0 2 0 0,8 1,25 0 1,25 0 0,8 1,25 0 1,25 0 0,9 1,111111 0 1,111111 0 0,9 1,111111 0 0 1,111111 sum 0 5,611111 1,111111 dan dari data diatas, yang versi color lah yang lebih tinggi jadi dari pertanyaan nya isinya adalah VERSICOLOR sepal_length sepal_width petal_length petal_width species Sampel data 5 2 4,5 1,5 versicolor","title":"weight KNN"},{"location":"Weighted K-Nearest Neighbor/#weighted-k-nearest-neighbor","text":"klasifikasi data menggunakan metode W-KNN dengan sampel percobaan sebagai berikut: berikut adalah data yang diambil secara acak dari data iris sebanyak 100 sepal_length sepal_width petal_length petal_width species Training data sepal_length as A sepal_width as B petal_length as C petal_width as D species 6,9 3,1 5,1 2,3 virginica 6,7 3 5 1,7 versicolor 6,9 3,1 4,9 1,5 versicolor 6,7 3 5,2 2,3 virginica 6,7 3,1 4,7 1,5 versicolor 6,5 3,2 5,1 2 virginica 6,9 3,1 5,4 2,1 virginica 7 3,2 4,7 1,4 versicolor 6,5 3 5,2 2 virginica 6,8 2,8 4,8 1,4 versicolor 6,8 3 5,5 2,1 virginica 6,5 2,8 4,6 1,5 versicolor 6,7 3,1 4,4 1,4 versicolor 6,3 2,7 4,9 1,8 virginica 6,6 3 4,4 1,4 versicolor 6,6 2,9 4,6 1,3 versicolor 6,4 2,7 5,3 1,9 virginica 6,2 2,8 4,8 1,8 virginica 6,4 3,2 4,5 1,5 versicolor 6,4 3,2 5,3 2,3 virginica 6,3 3,3 4,7 1,6 versicolor 6,5 3 5,5 1,8 virginica 6,3 2,5 5 1,9 virginica 6,1 3 4,9 1,8 virginica 6,3 2,8 5,1 1,5 virginica 6,7 3,1 5,6 2,4 virginica 6,4 3,1 5,5 1,8 virginica 6,9 3,2 5,7 2,3 virginica 6,3 2,5 4,9 1,5 versicolor 6,7 3,3 5,7 2,1 virginica 6 3 4,8 1,8 virginica 6,4 2,8 5,6 2,1 virginica 6,4 2,8 5,6 2,2 virginica 6,4 2,9 4,3 1,3 versicolor 6,3 2,9 5,6 1,8 virginica 6,1 2,9 4,7 1,4 versicolor 7,2 3 5,8 1,6 virginica 6,1 3 4,6 1,4 versicolor 7,1 3 5,9 2,1 virginica 6,7 3,3 5,7 2,5 virginica 6,2 3,4 5,4 2,3 virginica 5,9 3,2 4,8 1,8 versicolor 6,5 3 5,8 2,2 virginica 5,9 3 5,1 1,8 virginica 6 2,7 5,1 1,6 versicolor 6 2,9 4,5 1,5 versicolor 6,7 2,5 5,8 1,8 virginica 6,8 3,2 5,9 2,3 virginica 6,2 2,9 4,3 1,3 versicolor 6 3,4 4,5 1,6 versicolor 6,3 3,4 5,6 2,4 virginica 6,1 2,8 4,7 1,2 versicolor 7,2 3,2 6 1,8 virginica 6,2 2,2 4,5 1,5 versicolor 6,3 2,3 4,4 1,3 versicolor 5,8 2,7 5,1 1,9 virginica 5,8 2,7 5,1 1,9 virginica 5,8 2,8 5,1 2,4 virginica 5,9 3 4,2 1,5 versicolor 7,4 2,8 6,1 1,9 virginica 6 2,2 5 1,5 virginica 6,1 2,6 5,6 1,4 virginica 5,7 2,5 5 2 virginica 6,1 2,8 4 1,3 versicolor 5,6 2,8 4,9 2 virginica 7,7 3 6,1 2,3 virginica 6,3 3,3 6 2,5 virginica 5,6 3 4,5 1,5 versicolor 5,7 2,8 4,5 1,3 versicolor 7,2 3,6 6,1 2,5 virginica 7,3 2,9 6,3 1,8 virginica 5,7 2,9 4,2 1,3 versicolor 5,7 3 4,2 1,2 versicolor 5,7 2,8 4,1 1,3 versicolor 5,8 2,6 4 1,2 versicolor 5,4 3 4,5 1,5 versicolor 5,6 2,7 4,2 1,3 versicolor 5,6 3 4,1 1,3 versicolor 5,8 2,7 3,9 1,2 versicolor 5,8 2,7 4,1 1 versicolor 5,5 2,6 4,4 1,2 versicolor 6 2,2 4 1 versicolor 7,6 3 6,6 2,1 virginica 5,5 2,5 4 1,3 versicolor 5,6 2,5 3,9 1,1 versicolor 5,5 2,3 4 1,3 versicolor 5,6 2,9 3,6 1,3 versicolor 7,9 3,8 6,4 2 virginica 7,7 2,8 6,7 2 virginica 5,5 2,4 3,8 1,1 versicolor 5,2 2,7 3,9 1,4 versicolor 5,7 2,6 3,5 1 versicolor 7,7 3,8 6,7 2,2 virginica 5,5 2,4 3,7 1 versicolor 4,9 2,5 4,5 1,7 virginica 7,7 2,6 6,9 2,3 virginica 5 2 3,5 1 versicolor 5 2,3 3,3 1 versicolor 5,1 2,5 3 1,1 versicolor 4,9 2,4 3,3 1 versicolor 5,7 3,8 1,7 0,3 setosa 5,1 3,8 1,9 0,4 setosa 5,4 3,9 1,7 0,4 setosa 5,1 3,3 1,7 0,5 setosa 5,4 3,4 1,7 0,2 setosa 5,4 3,4 1,5 0,4 setosa 5 3,5 1,6 0,6 setosa 4,8 3,4 1,9 0,2 setosa 5 3,4 1,6 0,4 setosa 5,7 4,4 1,5 0,4 setosa 5,4 3,7 1,5 0,2 setosa 5 3 1,6 0,2 setosa 5,3 3,7 1,5 0,2 setosa 5,1 3,7 1,5 0,4 setosa 5,2 3,5 1,5 0,2 setosa 5,1 3,8 1,6 0,2 setosa 5,1 3,4 1,5 0,2 setosa 5,5 3,5 1,3 0,2 setosa 5,1 3,8 1,5 0,3 setosa 5,4 3,9 1,3 0,4 setosa 5,2 3,4 1,4 0,2 setosa 5 3,4 1,5 0,2 setosa 5,1 3,5 1,4 0,3 setosa 4,8 3,1 1,6 0,2 setosa 4,8 3,4 1,6 0,2 setosa 5,5 4,2 1,4 0,2 setosa 5,8 4 1,2 0,2 setosa 5,1 3,5 1,4 0,2 setosa 4,7 3,2 1,6 0,2 setosa 5 3,3 1,4 0,2 setosa 4,9 3,1 1,5 0,1 setosa 4,9 3,1 1,5 0,1 setosa 4,9 3,1 1,5 0,1 setosa 5,2 4,1 1,5 0,1 setosa 5 3,6 1,4 0,2 setosa 4,9 3 1,4 0,2 setosa 4,8 3 1,4 0,3 setosa 5 3,5 1,3 0,3 setosa 4,6 3,1 1,5 0,2 setosa 4,8 3 1,4 0,1 setosa 5 3,2 1,2 0,2 setosa 4,6 3,4 1,4 0,3 setosa 4,6 3,2 1,4 0,2 setosa 4,7 3,2 1,3 0,2 setosa 4,4 2,9 1,4 0,2 setosa 4,5 2,3 1,3 0,3 setosa 4,4 3 1,3 0,2 setosa 4,4 3,2 1,3 0,2 setosa 4,6 3,6 1 0,2 setosa 4,3 3 1,1 0,1 setosa","title":"Weighted K-Nearest Neighbor"},{"location":"Weighted K-Nearest Neighbor/#menghitung-jarak","text":"sepal_length as A sepal_width as B petal_length as C petal_width as D species (A-S1)^2 (B-S2)^2 (C-S3)^2 (D-S4)^2 SQRT(D) 6,9 3,1 5,1 2,3 virginica 3,6 1,2 0,4 0,6 2,4 6,7 3 5 1,7 versicolor 2,9 1,0 0,3 0,0 2,0 6,9 3,1 4,9 1,5 versicolor 3,6 1,2 0,2 0,0 2,2 6,7 3 5,2 2,3 virginica 2,9 1,0 0,5 0,6 2,2 6,7 3,1 4,7 1,5 versicolor 2,9 1,2 0,0 0,0 2,0 6,5 3,2 5,1 2 virginica 2,3 1,4 0,4 0,3 2,1 6,9 3,1 5,4 2,1 virginica 3,6 1,2 0,8 0,4 2,4 7 3,2 4,7 1,4 versicolor 4,0 1,4 0,0 0,0 2,3 6,5 3 5,2 2 virginica 2,3 1,0 0,5 0,3 2,0 6,8 2,8 4,8 1,4 versicolor 3,2 0,6 0,1 0,0 2,0 6,8 3 5,5 2,1 virginica 3,2 1,0 1,0 0,4 2,4 6,5 2,8 4,6 1,5 versicolor 2,3 0,6 0,0 0,0 1,7 6,7 3,1 4,4 1,4 versicolor 2,9 1,2 0,0 0,0 2,0 6,3 2,7 4,9 1,8 virginica 1,7 0,5 0,2 0,1 1,6 6,6 3 4,4 1,4 versicolor 2,6 1,0 0,0 0,0 1,9 6,6 2,9 4,6 1,3 versicolor 2,6 0,8 0,0 0,0 1,8 6,4 2,7 5,3 1,9 virginica 2,0 0,5 0,6 0,2 1,8 6,2 2,8 4,8 1,8 virginica 1,4 0,6 0,1 0,1 1,5 6,4 3,2 4,5 1,5 versicolor 2,0 1,4 0,0 0,0 1,8 6,4 3,2 5,3 2,3 virginica 2,0 1,4 0,6 0,6 2,2 6,3 3,3 4,7 1,6 versicolor 1,7 1,7 0,0 0,0 1,9 6,5 3 5,5 1,8 virginica 2,3 1,0 1,0 0,1 2,1 6,3 2,5 5 1,9 virginica 1,7 0,3 0,3 0,2 1,5 6,1 3 4,9 1,8 virginica 1,2 1,0 0,2 0,1 1,6 6,3 2,8 5,1 1,5 virginica 1,7 0,6 0,4 0,0 1,6 6,7 3,1 5,6 2,4 virginica 2,9 1,2 1,2 0,8 2,5 6,4 3,1 5,5 1,8 virginica 2,0 1,2 1,0 0,1 2,1 6,9 3,2 5,7 2,3 virginica 3,6 1,4 1,4 0,6 2,7 6,3 2,5 4,9 1,5 versicolor 1,7 0,3 0,2 0,0 1,4 6,7 3,3 5,7 2,1 virginica 2,9 1,7 1,4 0,4 2,5 6 3 4,8 1,8 virginica 1,0 1,0 0,1 0,1 1,5 6,4 2,8 5,6 2,1 virginica 2,0 0,6 1,2 0,4 2,0 6,4 2,8 5,6 2,2 virginica 2,0 0,6 1,2 0,5 2,1 6,4 2,9 4,3 1,3 versicolor 2,0 0,8 0,0 0,0 1,7 6,3 2,9 5,6 1,8 virginica 1,7 0,8 1,2 0,1 1,9 6,1 2,9 4,7 1,4 versicolor 1,2 0,8 0,0 0,0 1,4 7,2 3 5,8 1,6 virginica 4,8 1,0 1,7 0,0 2,7 6,1 3 4,6 1,4 versicolor 1,2 1,0 0,0 0,0 1,5 7,1 3 5,9 2,1 virginica 4,4 1,0 2,0 0,4 2,8 6,7 3,3 5,7 2,5 virginica 2,9 1,7 1,4 1,0 2,6 6,2 3,4 5,4 2,3 virginica 1,4 2,0 0,8 0,6 2,2 5,9 3,2 4,8 1,8 versicolor 0,8 1,4 0,1 0,1 1,6 6,5 3 5,8 2,2 virginica 2,3 1,0 1,7 0,5 2,3 5,9 3 5,1 1,8 virginica 0,8 1,0 0,4 0,1 1,5 6 2,7 5,1 1,6 versicolor 1,0 0,5 0,4 0,0 1,4 6 2,9 4,5 1,5 versicolor 1,0 0,8 0,0 0,0 1,3 6,7 2,5 5,8 1,8 virginica 2,9 0,3 1,7 0,1 2,2 6,8 3,2 5,9 2,3 virginica 3,2 1,4 2,0 0,6 2,7 6,2 2,9 4,3 1,3 versicolor 1,4 0,8 0,0 0,0 1,5 6 3,4 4,5 1,6 versicolor 1,0 2,0 0,0 0,0 1,7 6,3 3,4 5,6 2,4 virginica 1,7 2,0 1,2 0,8 2,4 6,1 2,8 4,7 1,2 versicolor 1,2 0,6 0,0 0,1 1,4 7,2 3,2 6 1,8 virginica 4,8 1,4 2,3 0,1 2,9 6,2 2,2 4,5 1,5 versicolor 1,4 0,0 0,0 0,0 1,2 6,3 2,3 4,4 1,3 versicolor 1,7 0,1 0,0 0,0 1,4 5,8 2,7 5,1 1,9 virginica 0,6 0,5 0,4 0,2 1,3 5,8 2,7 5,1 1,9 virginica 0,6 0,5 0,4 0,2 1,3 5,8 2,8 5,1 2,4 virginica 0,6 0,6 0,4 0,8 1,6 5,9 3 4,2 1,5 versicolor 0,8 1,0 0,1 0,0 1,4 7,4 2,8 6,1 1,9 virginica 5,8 0,6 2,6 0,2 3,0 6 2,2 5 1,5 virginica 1,0 0,0 0,3 0,0 1,1 6,1 2,6 5,6 1,4 virginica 1,2 0,4 1,2 0,0 1,7 5,7 2,5 5 2 virginica 0,5 0,3 0,3 0,3 1,1 6,1 2,8 4 1,3 versicolor 1,2 0,6 0,3 0,0 1,5 5,6 2,8 4,9 2 virginica 0,4 0,6 0,2 0,3 1,2 7,7 3 6,1 2,3 virginica 7,3 1,0 2,6 0,6 3,4 6,3 3,3 6 2,5 virginica 1,7 1,7 2,3 1,0 2,6 5,6 3 4,5 1,5 versicolor 0,4 1,0 0,0 0,0 1,2 5,7 2,8 4,5 1,3 versicolor 0,5 0,6 0,0 0,0 1,1 7,2 3,6 6,1 2,5 virginica 4,8 2,6 2,6 1,0 3,3 7,3 2,9 6,3 1,8 virginica 5,3 0,8 3,2 0,1 3,1 5,7 2,9 4,2 1,3 versicolor 0,5 0,8 0,1 0,0 1,2 5,7 3 4,2 1,2 versicolor 0,5 1,0 0,1 0,1 1,3 5,7 2,8 4,1 1,3 versicolor 0,5 0,6 0,2 0,0 1,2 5,8 2,6 4 1,2 versicolor 0,6 0,4 0,3 0,1 1,2 5,4 3 4,5 1,5 versicolor 0,2 1,0 0,0 0,0 1,1 5,6 2,7 4,2 1,3 versicolor 0,4 0,5 0,1 0,0 1,0 5,6 3 4,1 1,3 versicolor 0,4 1,0 0,2 0,0 1,2 5,8 2,7 3,9 1,2 versicolor 0,6 0,5 0,4 0,1 1,3 5,8 2,7 4,1 1 versicolor 0,6 0,5 0,2 0,3 1,2 5,5 2,6 4,4 1,2 versicolor 0,3 0,4 0,0 0,1 0,8 6 2,2 4 1 versicolor 1,0 0,0 0,3 0,3 1,2 7,6 3 6,6 2,1 virginica 6,8 1,0 4,4 0,4 3,5 5,5 2,5 4 1,3 versicolor 0,3 0,3 0,3 0,0 0,9 5,6 2,5 3,9 1,1 versicolor 0,4 0,3 0,4 0,2 1,1 5,5 2,3 4 1,3 versicolor 0,3 0,1 0,3 0,0 0,8 5,6 2,9 3,6 1,3 versicolor 0,4 0,8 0,8 0,0 1,4 7,9 3,8 6,4 2 virginica 8,4 3,2 3,6 0,3 3,9 7,7 2,8 6,7 2 virginica 7,3 0,6 4,8 0,3 3,6 5,5 2,4 3,8 1,1 versicolor 0,3 0,2 0,5 0,2 1,0 5,2 2,7 3,9 1,4 versicolor 0,0 0,5 0,4 0,0 0,9 5,7 2,6 3,5 1 versicolor 0,5 0,4 1,0 0,3 1,4 7,7 3,8 6,7 2,2 virginica 7,3 3,2 4,8 0,5 4,0 5,5 2,4 3,7 1 versicolor 0,3 0,2 0,6 0,3 1,1 4,9 2,5 4,5 1,7 virginica 0,0 0,3 0,0 0,0 0,5 7,7 2,6 6,9 2,3 virginica 7,3 0,4 5,8 0,6 3,7 5 2 3,5 1 versicolor 0,0 0,0 1,0 0,3 1,1 5 2,3 3,3 1 versicolor 0,0 0,1 1,4 0,3 1,3 5,1 2,5 3 1,1 versicolor 0,0 0,3 2,3 0,2 1,6 4,9 2,4 3,3 1 versicolor 0,0 0,2 1,4 0,3 1,4 5,7 3,8 1,7 0,3 setosa 0,5 3,2 7,8 1,4 3,6 5,1 3,8 1,9 0,4 setosa 0,0 3,2 6,8 1,2 3,3 5,4 3,9 1,7 0,4 setosa 0,2 3,6 7,8 1,2 3,6 5,1 3,3 1,7 0,5 setosa 0,0 1,7 7,8 1,0 3,2 5,4 3,4 1,7 0,2 setosa 0,2 2,0 7,8 1,7 3,4 5,4 3,4 1,5 0,4 setosa 0,2 2,0 9,0 1,2 3,5 5 3,5 1,6 0,6 setosa 0,0 2,3 8,4 0,8 3,4 4,8 3,4 1,9 0,2 setosa 0,0 2,0 6,8 1,7 3,2 5 3,4 1,6 0,4 setosa 0,0 2,0 8,4 1,2 3,4 5,7 4,4 1,5 0,4 setosa 0,5 5,8 9,0 1,2 4,1 5,4 3,7 1,5 0,2 setosa 0,2 2,9 9,0 1,7 3,7 5 3 1,6 0,2 setosa 0,0 1,0 8,4 1,7 3,3 5,3 3,7 1,5 0,2 setosa 0,1 2,9 9,0 1,7 3,7 5,1 3,7 1,5 0,4 setosa 0,0 2,9 9,0 1,2 3,6 5,2 3,5 1,5 0,2 setosa 0,0 2,3 9,0 1,7 3,6 5,1 3,8 1,6 0,2 setosa 0,0 3,2 8,4 1,7 3,7 5,1 3,4 1,5 0,2 setosa 0,0 2,0 9,0 1,7 3,6 5,5 3,5 1,3 0,2 setosa 0,3 2,3 10,2 1,7 3,8 5,1 3,8 1,5 0,3 setosa 0,0 3,2 9,0 1,4 3,7 5,4 3,9 1,3 0,4 setosa 0,2 3,6 10,2 1,2 3,9 5,2 3,4 1,4 0,2 setosa 0,0 2,0 9,6 1,7 3,6 5 3,4 1,5 0,2 setosa 0,0 2,0 9,0 1,7 3,6 5,1 3,5 1,4 0,3 setosa 0,0 2,3 9,6 1,4 3,6 4,8 3,1 1,6 0,2 setosa 0,0 1,2 8,4 1,7 3,4 4,8 3,4 1,6 0,2 setosa 0,0 2,0 8,4 1,7 3,5 5,5 4,2 1,4 0,2 setosa 0,3 4,8 9,6 1,7 4,0 5,8 4 1,2 0,2 setosa 0,6 4,0 10,9 1,7 4,1 5,1 3,5 1,4 0,2 setosa 0,0 2,3 9,6 1,7 3,7 4,7 3,2 1,6 0,2 setosa 0,1 1,4 8,4 1,7 3,4 5 3,3 1,4 0,2 setosa 0,0 1,7 9,6 1,7 3,6 4,9 3,1 1,5 0,1 setosa 0,0 1,2 9,0 2,0 3,5 4,9 3,1 1,5 0,1 setosa 0,0 1,2 9,0 2,0 3,5 4,9 3,1 1,5 0,1 setosa 0,0 1,2 9,0 2,0 3,5 5,2 4,1 1,5 0,1 setosa 0,0 4,4 9,0 2,0 3,9 5 3,6 1,4 0,2 setosa 0,0 2,6 9,6 1,7 3,7 4,9 3 1,4 0,2 setosa 0,0 1,0 9,6 1,7 3,5 4,8 3 1,4 0,3 setosa 0,0 1,0 9,6 1,4 3,5 5 3,5 1,3 0,3 setosa 0,0 2,3 10,2 1,4 3,7 4,6 3,1 1,5 0,2 setosa 0,2 1,2 9,0 1,7 3,5 4,8 3 1,4 0,1 setosa 0,0 1,0 9,6 2,0 3,6 5 3,2 1,2 0,2 setosa 0,0 1,4 10,9 1,7 3,7 4,6 3,4 1,4 0,3 setosa 0,2 2,0 9,6 1,4 3,6 4,6 3,2 1,4 0,2 setosa 0,2 1,4 9,6 1,7 3,6 4,7 3,2 1,3 0,2 setosa 0,1 1,4 10,2 1,7 3,7 4,4 2,9 1,4 0,2 setosa 0,4 0,8 9,6 1,7 3,5 4,5 2,3 1,3 0,3 setosa 0,3 0,1 10,2 1,4 3,5 4,4 3 1,3 0,2 setosa 0,4 1,0 10,2 1,7 3,6 4,4 3,2 1,3 0,2 setosa 0,4 1,4 10,2 1,7 3,7 4,6 3,6 1 0,2 setosa 0,2 2,6 12,3 1,7 4,1 4,3 3 1,1 0,1 setosa 0,5 1,0 11,6 2,0 3,9 dari jarak diatas kita bisa mengambil sampel mengetahui data yang akan dicari seperti contoh soal berikut : sepal_length sepal_width petal_length petal_width species Sampel data 5 2 4,5 1,5 ? dan diketahui hasilnya sebagai berikut : K=5 D 1/D Setosa versicolor virginica 0,5 2 0 2 0 0,8 1,25 0 1,25 0 0,8 1,25 0 1,25 0 0,9 1,111111 0 1,111111 0 0,9 1,111111 0 0 1,111111 sum 0 5,611111 1,111111 dan dari data diatas, yang versi color lah yang lebih tinggi jadi dari pertanyaan nya isinya adalah VERSICOLOR sepal_length sepal_width petal_length petal_width species Sampel data 5 2 4,5 1,5 versicolor","title":"menghitung jarak"},{"location":"fuzzy_c_means/","text":"IMPLEMENTASI FUZZY C-MEANS CLUSTERING DENGAN PYTHON \u00b6 PENGERTIAN FUZZY CLUSTERING \u00b6 Fuzzy clustering adalah proses menentukan derajat keanggotaan, dan kemudian menggunakannya dengan memasukkannya kedalam elemen data kedalam satu kelompok cluster atau lebih.Hal ini akan memberikan informasi kesamaan dari setiap objek. Satu dari sekian banyaknya algoritma fuzzy clustering yang digunakan adalah algoritma fuzzy clustering c means. Vektor dari fuzzy clustering, V={v1, v2, v3,\u2026., vc}, merupakan sebuah fungsi objektif yang didefinisikan dengan derajat keanggotaan dari Xj dan pusat cluster Vj. Algoritma fuzzy clustering c means membagi data yang tersedia dari setiap elemen data berhingga lalu memasukkannya kedalam bagian dari koleksi cluster yang dipengaruhi oleh beberapa kriteria yang diberikan. Berikan satu kumpulan data berhingga. X={x|,\u2026., xn} dan pusat data. Proses clustering pada dasarnya merupakan proses pembuatan himpunan yang memiliki anggota elemen-elemen yang akan dicluster. Pada algoritma clustering non\u2013fuzzy, nilai keanggotaan suatu elemen terhadap gugus atau cluster dinyatakan sebagai 0 atau 1, artinya setiap dokumen hanya bisa menjadi anggota satu cluster (1 sebagai anggota dan 0 bukan anggota). Padahal, jika informasi tentang data ditinjau kembali, satu data dapat menjadi anggota lebih dari satu cluster dengan derajat keanggotaan tertentu. Dengan fuzzy clustering, data dapat menjadi anggota beberapa cluster sekaligus. Dengan rumus : |(X1 \u2013 C1)|= |(X2\u2013 C1)|= Ket : X1 = data ke 1 Xi = data ke i C = (C1, C2) / kumpulan cluster C(n) = pusat cluster ke n U = (U11, U12) / Kumpulan derajat keanggotaan U(n) =Pusat derajat keanggotaan iterasi ke N ALGORITMA FUZZY C-MEANS CLUSTERING \u00b6 \\1. Menentukan Matriks X yang merupakan data yang akan dicluster, berukuran k x j, dengan k = jumlah data yang akan di-cluster dan j = jumlah variabel/atribut (kriteria). \\2. MenentukanJumlah cluster yang akan dibentuk (n >c \u2265 2). - pembobot (w > 1). - Maksimum iterasi (max n). - Kriteria penghentian/treshold (\u025b = nilai positif yang sangat kecil). - Menentukan fungsi obyektif awal (P0). \\3. Membentuk matriks partisi awal U (derajat keanggotaan dalam cluster) dengan ukuran k x i; matriks partisi biasanya dibuat acak, dengan k = jumlah data yang akan di-cluster dan i = jumlah cluster \\4. Hitung pusat cluster (V) untuk setiap cluster, menggunakan rumus Keterangan : Vij = pusat cluster pada cluster ke-i dan atribut ke-j. \u03bcik = data partisi (pada matriks U) pada cluster ke-i dan data ke-k. Xkj = data (pada matriks U) pada atribut ke-j dan data ke-k. w = pembobot \\5. Hitung nilai obyektif (Pn) dengan rumus : Keterangan : \u03bcik = data partisi (pada matriks U) pada cluster ke-i dan data ke-k. dik = fungsi ukuran jarak untuk jarak Euclidean pada pusat cluster ke-i dan data ke-k. w = pembobot. Pn = nilai obyektif pada iterasi ke-n. \\6. Perbaiki derajat keanggotaan setiap data pada setiap cluster (perbaiki matriks partisi dengan : dengan : Keterangan : \u03bcik = data partisi (pada matriks U) pada pusat cluster ke-i dan data ke-k. dik = fungsi ukuran jarak untuk jarak Euclidean pada pusat cluster ke-i dan data ke-k. djk = fungsi ukuran jarak untuk jarak Euclidean pada pusat cluster ke-j dan data ke-k. w = pembobot. Xkj = data (pada matriks U) pada atribut ke-j dan data ke-k. \\7. Menghentikan iterasi jika pusat cluster V tidak berubah. Alternatif kriteria penghentian adalah jika perubahan nilai error kurang dari treshold |Pn - Pn-1| < \u025b. Alternatif adalah ketika perulangan melebihi maksimum iterasi ( n > max n). Jika iterasi belum berhenti, kembali ke langkah 4 \\8. Jika iterasi berhenti, ditentukan cluster dari tiap-tiap data. Cluster dipilih berdasarkan nilai matriks partisi terbesar. CONTOH MENGHITUNG PUSAT CLUSTER \u00b6 f1 f2 1 2 1 2 1 1 3 3 2 4 5 6 5 7 5 6 6 6 7 8 6 8 7 7 pada saat iterasi 0: c1 c2 1 0,363735 0,632653 2 0,558824 0,441176 3 0,571429 0,428571 4 0,180851 0,819149 5 0,283951 0,716049 6 0,880952 0,119048 7 0,619048 0,380952 8 0,583333 0,416667 mencari pusat clustering : c1 5,192956 4,624605 c2 4,771514 4,236214 update derajat keanggotaan : c1 c2 1 0,0361 0,03781 2 0.02806 0,02905 3 0,06736 0,07356 4 0,051975 0,031055 5 0,0634 0,027 6 0,100816 0,081757 7 0,04568 0,04241 8 0,0483 0,04451 CONTOH CODE C-MEANS CLUSTERING \u00b6 import random import csv list1 = [] with open ( 'Iris.csv' , 'r' ) as filecsv : datafile = csv . reader ( filecsv ) for data in datafile : list1 . append ( data ) print ( list1 ) c = len ( list1 [ 0 ]) r = len ( list1 ) clu = int ( input ( 'masukan banyak cluster : ' )) #Masukan data data = [] for i in range ( r - 1 ): temp_data = [] for j in range ( c ): temp_data . append ( float ( list1 [ i + 1 ][ 1 ])) temp_data . append ( float ( list1 [ i + 1 ][ 2 ])) temp_data . append ( float ( list1 [ i + 1 ][ 3 ])) temp_data . append ( float ( list1 [ i + 1 ][ 4 ])) data . append ( temp_data ) pangkat = int ( input ( 'masukan pangkat : ' )) #Random Cluster clu_random = [] for i in range ( r - 1 ): list = [] for j in range ( clu ): inp = random . randrange ( 1 , 10 ); list . append ( inp / 10 ) clu_random . append ( list ) stop = False no = 1 while not stop : print ( \"Iterasi Ke-\" , no ) #klas Clouster cluster = [] for i in range ( clu ): xy = [] for j in range ( c ): pembilang = [] penyebut = [] for k in range ( r - 1 ): hasil = data [ k ][ j ] * ( clu_random [ k ][ i ] ** pangkat ) hasil2 = clu_random [ k ][ i ] ** pangkat pembilang . append ( hasil ) penyebut . append ( hasil2 ) xy . append ( sum ( pembilang ) / sum ( penyebut )) cluster . append ( xy ) #mencari Centroid centroid = [] for i in range ( clu ): cent = [] for j in range ( r - 1 ): tampung = [] for k in range ( c ): hasil = data [ j ][ k ] - cluster [ i ][ k ] hasil = hasil ** 2 tampung . append ( hasil ) cent . append ( sum ( tampung ) ** ( 1 / 2 )) centroid . append ( cent ) #Update update = [] for i in range ( r - 1 ): niu = [] for j in range ( clu ): pembilang = ( 1 / centroid [ j ][ i ]) ** ( 1 / ( pangkat - 1 )) list_peny = [] for k in range ( clu ): penyebut = ( 1 / centroid [ k ][ i ]) ** ( 1 / ( pangkat - 1 )) list_peny . append ( penyebut ) niu . append ( pembilang / sum ( list_peny )) update . append ( niu ) #penampilan data asli print ( \"asli\" ) for i in range ( len ( data )): print ( data [ i ], ' ' , clu_random [ i ]) #penampilan data update print ( \"update\" ) for i in range ( len ( data )): print ( data [ i ], ' ' , update [ i ]) #pengecekan Treshold hasil = [] for i in range ( len ( update )): for j in range ( len ( update [ i ])): hasil . append ( abs ( update [ i ][ j ] - clu_random [ i ][ j ])) if ( sum ( hasil ) < 0.5 ): stop = True clu_random = update no = no + 1 print () MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"fuzzy_c_means"},{"location":"fuzzy_c_means/#implementasi-fuzzy-c-means-clustering-dengan-python","text":"","title":"IMPLEMENTASI FUZZY C-MEANS CLUSTERING DENGAN PYTHON"},{"location":"fuzzy_c_means/#pengertian-fuzzy-clustering","text":"Fuzzy clustering adalah proses menentukan derajat keanggotaan, dan kemudian menggunakannya dengan memasukkannya kedalam elemen data kedalam satu kelompok cluster atau lebih.Hal ini akan memberikan informasi kesamaan dari setiap objek. Satu dari sekian banyaknya algoritma fuzzy clustering yang digunakan adalah algoritma fuzzy clustering c means. Vektor dari fuzzy clustering, V={v1, v2, v3,\u2026., vc}, merupakan sebuah fungsi objektif yang didefinisikan dengan derajat keanggotaan dari Xj dan pusat cluster Vj. Algoritma fuzzy clustering c means membagi data yang tersedia dari setiap elemen data berhingga lalu memasukkannya kedalam bagian dari koleksi cluster yang dipengaruhi oleh beberapa kriteria yang diberikan. Berikan satu kumpulan data berhingga. X={x|,\u2026., xn} dan pusat data. Proses clustering pada dasarnya merupakan proses pembuatan himpunan yang memiliki anggota elemen-elemen yang akan dicluster. Pada algoritma clustering non\u2013fuzzy, nilai keanggotaan suatu elemen terhadap gugus atau cluster dinyatakan sebagai 0 atau 1, artinya setiap dokumen hanya bisa menjadi anggota satu cluster (1 sebagai anggota dan 0 bukan anggota). Padahal, jika informasi tentang data ditinjau kembali, satu data dapat menjadi anggota lebih dari satu cluster dengan derajat keanggotaan tertentu. Dengan fuzzy clustering, data dapat menjadi anggota beberapa cluster sekaligus. Dengan rumus : |(X1 \u2013 C1)|= |(X2\u2013 C1)|= Ket : X1 = data ke 1 Xi = data ke i C = (C1, C2) / kumpulan cluster C(n) = pusat cluster ke n U = (U11, U12) / Kumpulan derajat keanggotaan U(n) =Pusat derajat keanggotaan iterasi ke N","title":"PENGERTIAN FUZZY CLUSTERING"},{"location":"fuzzy_c_means/#algoritma-fuzzy-c-means-clustering","text":"\\1. Menentukan Matriks X yang merupakan data yang akan dicluster, berukuran k x j, dengan k = jumlah data yang akan di-cluster dan j = jumlah variabel/atribut (kriteria). \\2. MenentukanJumlah cluster yang akan dibentuk (n >c \u2265 2). - pembobot (w > 1). - Maksimum iterasi (max n). - Kriteria penghentian/treshold (\u025b = nilai positif yang sangat kecil). - Menentukan fungsi obyektif awal (P0). \\3. Membentuk matriks partisi awal U (derajat keanggotaan dalam cluster) dengan ukuran k x i; matriks partisi biasanya dibuat acak, dengan k = jumlah data yang akan di-cluster dan i = jumlah cluster \\4. Hitung pusat cluster (V) untuk setiap cluster, menggunakan rumus Keterangan : Vij = pusat cluster pada cluster ke-i dan atribut ke-j. \u03bcik = data partisi (pada matriks U) pada cluster ke-i dan data ke-k. Xkj = data (pada matriks U) pada atribut ke-j dan data ke-k. w = pembobot \\5. Hitung nilai obyektif (Pn) dengan rumus : Keterangan : \u03bcik = data partisi (pada matriks U) pada cluster ke-i dan data ke-k. dik = fungsi ukuran jarak untuk jarak Euclidean pada pusat cluster ke-i dan data ke-k. w = pembobot. Pn = nilai obyektif pada iterasi ke-n. \\6. Perbaiki derajat keanggotaan setiap data pada setiap cluster (perbaiki matriks partisi dengan : dengan : Keterangan : \u03bcik = data partisi (pada matriks U) pada pusat cluster ke-i dan data ke-k. dik = fungsi ukuran jarak untuk jarak Euclidean pada pusat cluster ke-i dan data ke-k. djk = fungsi ukuran jarak untuk jarak Euclidean pada pusat cluster ke-j dan data ke-k. w = pembobot. Xkj = data (pada matriks U) pada atribut ke-j dan data ke-k. \\7. Menghentikan iterasi jika pusat cluster V tidak berubah. Alternatif kriteria penghentian adalah jika perubahan nilai error kurang dari treshold |Pn - Pn-1| < \u025b. Alternatif adalah ketika perulangan melebihi maksimum iterasi ( n > max n). Jika iterasi belum berhenti, kembali ke langkah 4 \\8. Jika iterasi berhenti, ditentukan cluster dari tiap-tiap data. Cluster dipilih berdasarkan nilai matriks partisi terbesar.","title":"ALGORITMA FUZZY C-MEANS CLUSTERING"},{"location":"fuzzy_c_means/#contoh-menghitung-pusat-cluster","text":"f1 f2 1 2 1 2 1 1 3 3 2 4 5 6 5 7 5 6 6 6 7 8 6 8 7 7 pada saat iterasi 0: c1 c2 1 0,363735 0,632653 2 0,558824 0,441176 3 0,571429 0,428571 4 0,180851 0,819149 5 0,283951 0,716049 6 0,880952 0,119048 7 0,619048 0,380952 8 0,583333 0,416667 mencari pusat clustering : c1 5,192956 4,624605 c2 4,771514 4,236214 update derajat keanggotaan : c1 c2 1 0,0361 0,03781 2 0.02806 0,02905 3 0,06736 0,07356 4 0,051975 0,031055 5 0,0634 0,027 6 0,100816 0,081757 7 0,04568 0,04241 8 0,0483 0,04451","title":"CONTOH MENGHITUNG PUSAT CLUSTER"},{"location":"fuzzy_c_means/#contoh-code-c-means-clustering","text":"import random import csv list1 = [] with open ( 'Iris.csv' , 'r' ) as filecsv : datafile = csv . reader ( filecsv ) for data in datafile : list1 . append ( data ) print ( list1 ) c = len ( list1 [ 0 ]) r = len ( list1 ) clu = int ( input ( 'masukan banyak cluster : ' )) #Masukan data data = [] for i in range ( r - 1 ): temp_data = [] for j in range ( c ): temp_data . append ( float ( list1 [ i + 1 ][ 1 ])) temp_data . append ( float ( list1 [ i + 1 ][ 2 ])) temp_data . append ( float ( list1 [ i + 1 ][ 3 ])) temp_data . append ( float ( list1 [ i + 1 ][ 4 ])) data . append ( temp_data ) pangkat = int ( input ( 'masukan pangkat : ' )) #Random Cluster clu_random = [] for i in range ( r - 1 ): list = [] for j in range ( clu ): inp = random . randrange ( 1 , 10 ); list . append ( inp / 10 ) clu_random . append ( list ) stop = False no = 1 while not stop : print ( \"Iterasi Ke-\" , no ) #klas Clouster cluster = [] for i in range ( clu ): xy = [] for j in range ( c ): pembilang = [] penyebut = [] for k in range ( r - 1 ): hasil = data [ k ][ j ] * ( clu_random [ k ][ i ] ** pangkat ) hasil2 = clu_random [ k ][ i ] ** pangkat pembilang . append ( hasil ) penyebut . append ( hasil2 ) xy . append ( sum ( pembilang ) / sum ( penyebut )) cluster . append ( xy ) #mencari Centroid centroid = [] for i in range ( clu ): cent = [] for j in range ( r - 1 ): tampung = [] for k in range ( c ): hasil = data [ j ][ k ] - cluster [ i ][ k ] hasil = hasil ** 2 tampung . append ( hasil ) cent . append ( sum ( tampung ) ** ( 1 / 2 )) centroid . append ( cent ) #Update update = [] for i in range ( r - 1 ): niu = [] for j in range ( clu ): pembilang = ( 1 / centroid [ j ][ i ]) ** ( 1 / ( pangkat - 1 )) list_peny = [] for k in range ( clu ): penyebut = ( 1 / centroid [ k ][ i ]) ** ( 1 / ( pangkat - 1 )) list_peny . append ( penyebut ) niu . append ( pembilang / sum ( list_peny )) update . append ( niu ) #penampilan data asli print ( \"asli\" ) for i in range ( len ( data )): print ( data [ i ], ' ' , clu_random [ i ]) #penampilan data update print ( \"update\" ) for i in range ( len ( data )): print ( data [ i ], ' ' , update [ i ]) #pengecekan Treshold hasil = [] for i in range ( len ( update )): for j in range ( len ( update [ i ])): hasil . append ( abs ( update [ i ][ j ] - clu_random [ i ][ j ])) if ( sum ( hasil ) < 0.5 ): stop = True clu_random = update no = no + 1 print () MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"CONTOH CODE C-MEANS CLUSTERING"},{"location":"gaus/","text":"Eliminasi Gauss Jordan \u00b6 \u200b Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. \u200b Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan \u00b6 \u00b6 Listing Program \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u00b6 Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program \u00b6 from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel \u00b6 Listing Program \u00b6 def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Elimination Gauss"},{"location":"gaus/#eliminasi-gauss-jordan","text":"\u200b Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. \u200b Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan"},{"location":"gaus/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan"},{"location":"gaus/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program"},{"location":"gaus/#eliminasi-gauss-jacobi","text":"Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi"},{"location":"gaus/#listing-program_1","text":"from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program"},{"location":"gaus/#program-gauss-seidel","text":"","title":"Program Gauss Seidel"},{"location":"gaus/#listing-program_2","text":"def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Listing Program"}]}